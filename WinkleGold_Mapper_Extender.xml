<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE muclient>
<muclient>
<plugin
   name="WinkleGold_Mapper_Extender"
   author="WinkleWinkle"
   id="b6eae87ccedd84f510b74715"
   language="Lua"
   purpose="Extends mapper functionality"
   date_written="2010-09-01 16:37:14"
   requires="4.51"
   version="1.4"
   save_state="y"
   >

<description trim="n">
<![CDATA[

MAPPER EXTENDER USAGE:

===== SHOW THIS HELP =============>
>    extender help
        - shows only this help
>    ww help
        - all winklewinkle(tm) plugins show help

===== RUNNING ====================>
>   xrunto [areaname]
        - Runs you via mapper goto/walkto to the first room you discovered in that area
		
>   xrt [areaname]
        - Same as "xrunto"
		
>   xmapper move <roomid>		
        - uses set movement speed to move to the specified room id

>   xmapper move <roomid> <walk|run>
        - uses a temporary movement speed to move to the specified room id
		
===== SEARCHING ==================>
>   xm [roomname]	
        - Lists and numbers rooms that match the [roomname] exactly, and then partial matches in the current area
		
>   xmall [roomname]
        - Lists and numbers rooms that match the [roomname] exactly, and then partial matches in all areas

>   xroutes
        - Lists speedwalk routes to every zone that has a start room set
	
>   fm [mobname] or xcp/qq index #
        - Find location of mob name from current area in database.

>   fma [mobname] or xcp/gq index #
        - Find location of mob name from all areas in database.
		
===== ROOMS ======================>
>   go [index]
        - Will run you with mapper goto/walkto to the first room in a numbered room list
		
>   go
        - The same as typing "go 1"
		
>   nx
        - Will run you to the next numbered room, "go" then "nx" would be the same as typing "go 1" then "go 2"
		
===== CAMPAIGNS / GQUESTS ==================>
>   xcp	
        - Lists all active campaign mobs in a numbered list (see xcp [index])
		
>   xcp [index]
        - Area CP runs you to the area of that CP item and does a Quick-Where on your mob. Type "go [index]" after this to go to the
	    first known room found (if any)
        - Room CP lists all known rooms that exactly match your CP room name. Type "go [index]" to run to the right room (if any).
        
>   qq
        - refresh the global quest list (if you are on a global quest)
          This will also refresh the GUI
          
>   qq [index]
        - same as xcp but for gquests

>   xlist
        - displays debug information for the last cp/gq list received
        - this will show the original list, and any guesses s&d has ruled out
          

===== MOB SUBS ===================>
>   mobsub [index]
        - Creates a mob substitution for whichever entry in your CP or GQ.
          Index can be either a number corresponding to your current list's items or Q or C.
          "mobsub Q" is your current quest mob, "mobsub C" allows you to create a custom mob sub

>   delmobsub [index]
        - Deletes a mob substitution for whichever entry in your CP or GQ
          Index can be either a number corresponding to your current list's items or Q when deleting.
	
===== NOTES ======================>

>   roomnote
        - Lists all mapper notes for the current room (if any).
		
>   roomnote area
        - Lists all mapper notes for the current area (if any). Useful for mazes

===== SETTINGS ======================>
>   xset
        - Display current xset settings and options

>   xset noexp <threshold>
        - Sets noexp threshold at the number set, this will automatically toggle
          noexp on if you are able take a CP to prevent leveling. If you
          set this to 0 it disables noexp.

>   xset mark
        - Sets the current room you are in to be the "first" room of that area
        
>   xset speed
        - Toggles the use of mapper goto/walkto for all movement commands
		
>   xset speed <walk|run>
        - changes the use of mapper goto/walkto for all movement commands

>   xset pk
        - Toggles the display of PK flag in room searches

>   xset roomid
        - Toggles the display of area name/roomid when moving or looking in a room
	
>   xset vidblain
        - Toggles a hack that will allow you to speedwalk to vidblain areas if you do not have a portal to use.

>   xset autocon
        - Toggles auto-consider after arriving at destination. This collects information for your mob database.
        
>   xset autoscan
        - Toggles autoscan after arriving at destination. This collects information for your mob database.
	
>   xset silentmode
        - Toggles hiding cp/gq checks from main window unless you do a manual check
		
>   xset reset gui
        - Will reset the X, Y and Z position of the Extender GUI

>   xset reducespam
        - Removes "Ignoring due to level messages" from cp/gq entries and also help text (xcp # and go # instructions in cp/gq check output)
          This is enabled by default, if you outlevel your cp and need to see it, toggle it back on.

>   xareas
        - Forces a manual re-indexing of the areas list
        
===== TO CREATE A CEXIT / MAP A PORTAL ==========>

http://code.google.com/p/aardwolf-scriptalicious/wiki/MapperHelp
		
]]>
</description>

</plugin>

<!--  Timers  -->

<timers>
	
	<timer
		name="execute_in_area_timer"
		script="execute_in_area_tick"
		enabled="n"
		second="0.25">
	</timer>
	
	<timer
		name="sqlQueue_timer"
		script="check_sql_queue"
		enabled="y"
		second="0.2">
	</timer>

</timers>

<aliases>

	<alias
		match="^ext debug$"
		regexp="y"
		enabled="y"
		sequence="100"
		script="ext_debug"
	>
	</alias>
   <alias
		match="^xlist$"
		regexp="y"
		enabled="y"
		sequence="100"
		script="xlist"
	>
   </alias>
      <alias
		match="^xpath( (?<id>.+))?$"
		regexp="y"
		enabled="y"
		sequence="100"
		script="xpath"
	>
   </alias>
	<alias
		match="^scheck$"
		regexp="y"
		enabled="y"
		sequence="100"
		script="silent_check_gq"
	>
	</alias>

	<alias match="^(?:ww|extender) help$"
		enabled="y"
		sequence="100"
		send_to="12"
		regexp="y"
		keep_evaluating="y"		
	>
	<send>
		ColourNote("MediumSeaGreen", "", GetPluginInfo (GetPluginID (), 3))
	</send>
	</alias>
   
	
   <alias
		match="^xset pk$"
		regexp="y"
		enabled="y"
		sequence="100"
		script="xset_pk"
	>
	</alias>
   <alias
		match="^ping$"
		regexp="y"
		enabled="y"
		sequence="100"
		script="ping"
	>
	</alias>
   <alias
		match="^xset$"
		regexp="y"
		enabled="y"
		sequence="100"
		script="xset_help"
	>
	</alias>
	
	<!--<alias
		match="^xset import starts$"
		regexp="y"
		enabled="y"
		sequence="100"
		script="check_old_starts"
	> 
	</alias> -->

	<alias
		match="^xset reducespam$"
		enabled="y"
		regexp="y"
		sequence="100"
		ignore_case="y"
		script="xset_reducespam"
	>
	</alias>
	
	<alias
		match="^xset silentmode$"
		enabled="y"
		regexp="y"
		sequence="100"
		ignore_case="y"
		script="xset_silentmode"
	>
	</alias>
   <alias
      match="^xset roomid$"
		enabled="y"
		regexp="y"
		sequence="100"
		ignore_case="y"
		script="xset_roomid"
	>
	</alias>

	<alias
		match="^xset autoscan$"
		enabled="y"
		regexp="y"
		sequence="100"
		ignore_case="y"
		script="xset_autoscan"
	>
	</alias>
   
   <alias
		match="^xset autocon$"
		enabled="y"
		regexp="y"
		sequence="100"
		ignore_case="y"
		script="xset_autocon"
	>
	</alias>
	
	<alias match="^xset mark$"
		enabled="y"
		sequence="100"
		script="xset_to_mark"
		regexp="y"
	>
	</alias>

	<alias match="^xset vidblain$"
		enabled="y"
		sequence="99"
		script="set_check_vidblain"
		regexp="y"
	>
	</alias>

	<alias match="^xru?n?to? (.+)$"
		enabled="y"
		sequence="100"
		script="xrun_to"
		regexp="y"
	>
	</alias>
	
	<alias match="^xroutes$"
		enabled="y"
		sequence="100"
		script="xroutes"
		regexp="y"
	>
	</alias>
	
	<alias match="^xareas$"
		enabled="y"
		sequence="100"
		script="get_area_index"
		regexp="y"
	>
	</alias>

	<alias match="^xm(?:\ {(?<mob>[^\}]+)\})? (?<loc>.+)$"
		enabled="y"
		sequence="100"
		script="map_area"
		regexp="y"
	>
	</alias>

	<alias match="^xmal?l?(?:\ {(?<mob>[^\}]+)\})? (?<loc>.+)$"
		enabled="y"
		sequence="99"
		script="map_area_all"
		regexp="y"
		keep_evaluating="n"
	>
	</alias>

	<alias match="^(?<cmd>cp|ca|cam|camp|campa|campai|campaig|campaign) (?<param>c|ch|che|chec|check)$"
		enabled="y"
		sequence="5"
		script="xcp_check"
		regexp="y"
	>
	</alias>
   
   <alias match="^(?<cmd>gq|gqu|gque|gques|gquest) (?<param>c|ch|che|chec|check)$"
		enabled="y"
		sequence="5"
		script="gq_list"
		regexp="y"
	>
	</alias>
   
	<alias match="^(?<cmd>xcp) ?(?<param>c|ch|che|chec|check|test)?$"
		enabled="y"
		sequence="6"
		script="xcp_check"
		regexp="y"
	>
	</alias>

	<alias match="^got?o?( (?<id>.+))?$"
		enabled="y"
		sequence="100"
		script="goto_number"
		regexp="y"
	>
	</alias>

	<alias match="^nx$"
		enabled="y"
		sequence="100"
		script="goto_next"
		regexp="y"
	>
	</alias>

	<alias match="^(xcp|cp|ca|cam|camp|campa|campaign) (?<index>[0-9]+)$"
		enabled="y"
		sequence="100"
		script="goto_cp"
		regexp="y"
	>
	</alias>
   
   <alias match="^mobsub (?<index>[0-9]+|Q|q|C|c)$"
		enabled="y"
		sequence="100"
		script="create_mobsub"
		regexp="y"
	>
	</alias>
   
   <alias match="^delmobsub (?<index>[0-9]+|Q|q)$"
		enabled="y"
		sequence="100"
		script="delete_mobsub"
		regexp="y"
	>
	</alias>

	<alias match="^xset speed ?(?<speed>run|walk)?$"
		enabled="y"
		sequence="100"
		script="set_speed"
		regexp="y"
	>
	</alias>
   
   <alias match="^xset noexp (?<value>[0-9]+)$"
		enabled="y"
		sequence="100"
		script="set_noexp"
		regexp="y"
	>
   </alias>
   <alias match="^xset noexp$"
		enabled="y"
		sequence="100"
		script="set_noexp"
		regexp="y"
	>
	</alias>
	
	<alias match="^xma?p?p?e?r? move (?<roomid>[0-9]+) ?(?<speed>run|walk)?$"
		enabled="y"
		sequence="95"
		script="move_trigger"
		regexp="y"
	>
	</alias>

	<alias match="^r(?:oomnote|n)$"
		enabled="y"
		sequence="100"
		script="room_note"
		regexp="y"
	>
	</alias>

	<alias match="^r(?:oomnote|n) a(?:rea)?(?: (?<areaid>.+))?$"
		enabled="y"
		sequence="99"
		script="room_note_area"
		regexp="y"
	>
	</alias>

 	<alias match="^xmapper purge room$"
		enabled="y"
		sequence="100"
		script="map_purgeroom"
		regexp="y"
	>
	</alias>

	<alias name="runsql"
		match="^runsql (?<sql>.+)$"
		enabled="y"
		sequence="1"
		script="RunSql"
		regexp="y"
	>
	</alias>

        <alias name="execsql"
		match="^execsql (?<sql>.+)$"
		enabled="y"
		sequence="1"
		script="ExecSql"
		regexp="y"
	>
        </alias>
       
	<alias match="^qqsim$"
		enabled="y"
		sequence="1"
		script="gq_list_simulate"
		regexp="y"
	>
	</alias>

	<alias match="^qqrep(?:ort)? (?<channel>.+)$"
		enabled="y"
		sequence="100"
		script="qq_report"
		regexp="y"
	>
	</alias>
	
	<alias match="^qq$"
		enabled="y"
		sequence="2"
		script="gq_list"
		regexp="y"
	>
	</alias>

	<alias match="^qq (?<index>[0-9]+)$"
		enabled="y"
		sequence="2"
		script="goto_gq"
		regexp="y"
	>
	</alias>
	<alias
		script="check_mob_in_mapper"
		match="Mob Map Check"
		enabled="y"
		sequence="100"
		ignore_case="y"
	>
	</alias>
	<alias
		script="find_mob_area"
		match="fm *"
		enabled="y"
		sequence="100"
		ignore_case="y"
	>
	</alias>
	<alias
		script="end_hunt_lookup"
		match="fm"
		enabled="y"
		sequence="99"
		ignore_case="y"
		>
	</alias>
	<alias
		script="find_mob_all"
		match="fma *"
		enabled="y"
		sequence="100"
		ignore_case="y"
	>
    </alias>
	<alias
		match="^xset suspend page size$"
		enabled="y"
		regexp="y"
		sequence="100"
		ignore_case="y"
		script="suspend_page_size"
	>
	</alias>

	<alias
		match="^xset resume page size$"
		enabled="y"
		regexp="y"
		sequence="100"
		ignore_case="y"
		script="resume_page_size"
	>
	</alias>

</aliases>

<triggers>

	<trigger
		name="trg_cp_request"
		match="^(.+) tells you \'Good luck in your campaign\!\'$"
		script="xcp_cp_started"
		enabled="y"
		regexp="y"
		sequence="100"
		send_to="12"
	>
		<send>Execute("cp c")</send>
	</trigger>
   
   <trigger
		name="trg_gq_join"
		match="^You have now joined Global Quest \# (?<gqnum>\d+)\. See 'help gquest' for available commands\.$"
		script="gq_joined"
		enabled="y"
		regexp="y"
		sequence="100"
		send_to="12"
	>
	</trigger>
   
   <trigger
		name="trg_gq_not_started"
		match="^Global Quest \# (?<gqnum>\d+) .* has not yet started\.$"
		script="capture_gq_end"
		enabled="y"
		regexp="y"
		sequence="100"
		send_to="12"
	>
	</trigger>
   <trigger
		name="trg_gq_started"
		match="^Global Quest: Global quest \# (?<gqnum>\d+) .* has now started\.$"
		script="gq_started"
		enabled="y"
		regexp="y"
		sequence="100"
		send_to="12"
	>
	</trigger>

	<trigger 
		name="trg_cp_mob_dead"
		match="^Congratulations, that was one of your CAMPAIGN mobs!$"
		regexp="y"
		enabled="y"
		sequence="100"
      script="event_cp_mob_dead"
	>
	</trigger>
	
	<trigger 
		name="trg_gq_mob_dead"
		match="^Congratulations, that was one of the GLOBAL QUEST mobs!$"
		regexp="y"
		enabled="y"
		sequence="100"
		send_to="12"
	>
		<send>
		BroadcastPlugin(680, "0")
		Execute("qq")
		</send>
	</trigger>

	<trigger match="^You still have to kill \* (?<mob>[^\(]+) \((?<where>.+?)(?<isdead> - Dead)?\)\.?$"
		name="trg_xcp_line"
		script="xcp_index_line"
		enabled="n"
		regexp="y"
		omit_from_output="y"
		sequence="500">
	</trigger>

	<trigger match="^(?!You still have to kill \*)"
		name="trg_xcp_line_end"
		script="xcp_index_line_end"
		enabled="n"
		regexp="y"
		omit_from_output="n"
		sequence="500">
	</trigger>

	<trigger match="You are not currently on a campaign."
		name="trg_xcp_line_end_none"
		script="xcp_end"
		enabled="y"
		regexp="n"
		omit_from_output="n"
		sequence="500">
	</trigger>
	
	<trigger
		match="CONGRATULATIONS! You have completed your campaign."
		script="xcp_end"
		name="trg_xcp_complete"
		enabled="y"
		regexp="n"
		sequence="100"
		keep_evaluating="y"
		>
	</trigger>
   
	<trigger
		match="^You may take a campaign at this level\.$"
		script="xcp_may_take"
		name="trg_xcp_may_take"
		enabled="y"
		regexp="y"
		omit_from_output="n"
		sequence="500"
		>
	</trigger>
   
   <trigger
      match="^You raise a level! You are now level (.+)\.$"
		script="event_player_level"
		name="trg_player_leveled"
		enabled="y"
		regexp="y"
		omit_from_output="n"
		sequence="500"
		>
	</trigger>
   
   <trigger
		match="^You will have to level before you can go on another campaign\.$"
		script="xcp_must_level"
      name="trg_xcp_must_level"
		enabled="y"
		regexp="y"
		omit_from_output="n"
		sequence="500"
		>
	</trigger>
   
   <trigger
		match="^You will no longer receive experience\. Happy questing\!$"
      name="trg_noexp_on"
		script="event_noexp_on"
      enabled="y"
		regexp="y"
		omit_from_output="n"
		sequence="500"
      send_to="12"
		>
	</trigger>
   
   <trigger
		match="^You will now receive experience\. Happy leveling\!$"
      name="trg_noexp_off"
      script="event_noexp_off"
		enabled="y"
		regexp="y"
		omit_from_output="n"
		sequence="500"
      send_to="12"
		>
	</trigger>
	
   <!-- match="^You have \d+ (?:day|days), \d+ (?:hour|hours) and \d+ (?:minute|minutes) left to finish this campaign\.$"
   Old match was this but changed to more generic because doesn't match on 
   "You have 13 hours and 7 minutes left to finish this campaign"
   and we don't use the days/hours/minutes info atm anyhow -->
   
   <trigger
		match="^You have (.+) left to finish this campaign\.$"
		script="process_cp_check"
		name="trg_process_cp_check"
		omit_from_output="n"
		enabled="y"
		regexp="y"
		sequence="100"
		keep_evaluating="y"
		>
	</trigger>
	
	<trigger
		match="^Note\: One or more target names in this campaign might be slightly scrambled\.$"
		script="xcp_note_scrambled"
		name="trg_cp_check_note_scrambled"
		enabled="y"
		regexp="y"
		omit_from_output="y"
		omit_from_log="y"
		sequence="100"
		keep_evaluating="y"
		>
	</trigger>
	
	<trigger
		match="^Note\: Dead means that the target is dead, not that you have killed it\.$"
		name="trg_gag_dead_target"
		enabled="y"
		regexp="y"
		omit_from_output="y"
		omit_from_log="y"
		sequence="100"
		keep_evaluating="y"
		>
	</trigger>
	<trigger
		match="^Note\: One or more target names in this gquest might be slightly scrambled\.$"
		name="trg_gq_check_note_scrambled"
		enabled="y"
		regexp="y"
		omit_from_output="y"
		sequence="100"
		keep_evaluating="y"
		>
	</trigger>
	
	<trigger
		match="^Note\: Dead means that the target is dead, not that you have killed it\.$"
		script="xcp_note_dead"
		name="trg_cp_check_note_dead"
		enabled="y"
		regexp="y"
		omit_from_output="n"
		sequence="100"
		keep_evaluating="y"
		>
	</trigger>
	
	<trigger match="              [ Listing all areas in range * to * ]"
		name="trg_area_index_start_gag"
		script="area_index_start_gag"
		enabled="n"
		regexp="n"
		omit_from_output="y"
		omit_from_log="y"
		sequence="100">
	</trigger>

	<trigger match="^From To   Lock  Builder          Area Name"
		name="trg_area_index_start"
		script="area_index_start"
		enabled="n"
		regexp="y"
		omit_from_output="y"
		omit_from_log="y"
		sequence="100">
	</trigger>
	
	<trigger match="---- ---- ----  ---------------  ------------------------------"
		name="trg_area_index_gag1"
		enabled="n"
		regexp="n"
		omit_from_output="y"
		omit_from_log="y"
		sequence="100">
	</trigger>
	
	<trigger match="^---------------------------------------------------------------$"
		name="trg_area_index_end"
		script="area_index_end"
		enabled="n"
		regexp="y"
		omit_from_output="y"
		omit_from_log="y"
		sequence="100">
	</trigger>
	
	<trigger match="^ (?<min>[0-9 ]{3})  (?<max>[0-9 ]{3})  (?<lock>[0-9 ]{3})  (?<author>.{15})  (?<area>.+)$"
		name="trg_area_index_line"
		script="area_index_line"
		enabled="n"
		regexp="y"
		omit_from_output="y"
		omit_from_log="y"
		sequence="100">
	</trigger>

	<trigger match="\'Lock\' means you cannot enter until you are that level or higher\.$"
		name="trg_area_index_gag2"
		enabled="y"
		regexp="y"
		send_to="14"
		omit_from_output="y"
		omit_from_log="y"
		sequence="100">
		<send>EnableTrigger("trg_area_index_gag2", false)</send>
	</trigger>

	<trigger match="^You still have to kill (?<qty>[0-9]) \* (?<mob>[^\(]+) \((?<where>.+?)(?<isdead> - Dead)?\)$"
		name="x_gq_line"
		group="x_gq"
		enabled="n"
		regexp="y"
		omit_from_output="y"
		sequence="500"
		script="capture_gq_line"
		>
	</trigger>

	<trigger match="^(?!You still have to kill )"
		name="x_gq_line_end"
		group="x_gq"
		enabled="n"
		regexp="y"
		omit_from_output="n"
		sequence="500"
		script="capture_gq_line_end"
		>
	</trigger>

	<trigger match="^You are not in a global quest\.$"
		name="x_gq_line_end_none"
		enabled="y"
		regexp="y"
		omit_from_output="n"
		sequence="500"
		script="capture_gq_end"
		>
	</trigger>
   
   <trigger match="^You are no longer part of Global Quest # .+ and will be unable to rejoin\.$"
		name="x_gq_self_quit"
		enabled="y"
		regexp="y"
		omit_from_output="n"
		sequence="500"
		script="capture_gq_end"
		>
	</trigger>
   
   <trigger
		name="trg_gq_ended"
		match="^Global Quest: Global quest \# (?<gqnum>\d+) .* is now over\.$"
		script="gq_ended"
		enabled="y"
		regexp="y"
		sequence="100"
		send_to="12"
	>
	</trigger>

   <trigger match="^You have already completed this global quest\.$"
		name="x_gq_already_completed"
		enabled="y"
		regexp="y"
		omit_from_output="n"
		sequence="500"
		script="capture_gq_end"
		>
	</trigger>
	
	<trigger match="^Campaign cleared\.$"
		name="trg_cp_quit"
		enabled="y"
		regexp="y"
		omit_from_output="n"
		sequence="500"
		script="xcp_end"
		>
	</trigger>

   <trigger match="^{PING}$"
      regexp="y"
		enabled="n"
		name="trg_ping"
		script="pong"
		omit_from_output="y"
		omit_from_log="y"
		sequence="100"
	></trigger>
	<trigger match="^{scan}$"
		regexp="y"
		enabled="y"
		name="trg_scan_trigger_start"
		script="scan_trigger_start"
		omit_from_output="y"
		omit_from_log="y"
		sequence="100"
	></trigger>
   <trigger match="^Tag option scan turned ON$"
		regexp="y"
		enabled="y"
		name="trg_tag_scan_on"
		omit_from_output="y"
		omit_from_log="y"
		sequence="100"
      
	></trigger>
	<trigger match="^Right here you see:$"
		regexp="y"
		enabled="n"
		name="trg_scan_trigger_right_here"
		script="scan_trigger_right_here"
		sequence="100"
	></trigger>

	<trigger
		enabled="n"
		match="^(?:[ ]{5}- (?:\[AFK\] )?(?:\([^\)]+\) )*(?<mob>.+))+$"
		regexp="y"
		name="trg_scan_trigger_right_here_mob"
		omit_from_output="y"
		omit_from_log="y"
		script="scan_trigger_right_here_mob"
		sequence="100"
	></trigger>

	<trigger match="^[23]? ?(?:North|South|East|West|Up|Down) from here you see:$"
		regexp="y"
		enabled="n"
		group="trg_scan_trigger_end"
		script="scan_trigger_end"
		sequence="100"
	></trigger>

	<trigger match="^{/scan}$"
		regexp="y"
		enabled="y"
		omit_from_output="y"
		omit_from_log="y"
		name="trg_scan_trigger_tag_end"
		send_to="12"
		sequence="100"
	>
	<send>
		EnableTrigger("trg_scan_trigger_tag_end", false)
		EnableTrigger("trg_scan_trigger_right_here_mob", false)
	</send>
	</trigger>

	<!-- consider triggers -->
	<trigger match="^(?:\(.*\) )?You would stomp (?<mob>.+) into the ground\.$"
      regexp="y"
      name="a"
		enabled="y"
		group="consider"
		script="scan_trigger_right_here_mob"
		sequence="100"
      omit_from_output="y"
		omit_from_log="y"
	></trigger>
   
	<trigger match="^(?:\(.*\) )?(?<mob>.+) would be easy\, but is it even worth the work out\?$"
      regexp="y"
      name="b"
		enabled="y"
		group="consider"
		script="scan_trigger_right_here_mob"
		sequence="100"
      omit_from_output="y"
		omit_from_log="y"
	></trigger>
   
	<trigger match="^(?:\(.*\) )?No Problem\! (?<mob>.+) is weak compared to you\.$"
      regexp="y"
      name="c"
		enabled="y"
		group="consider"
		script="scan_trigger_right_here_mob"
		sequence="100"
      omit_from_output="y"
		omit_from_log="y"
	></trigger>
   
	<trigger match="^(?:\(.*\) )?(?<mob>.+) looks a little worried about the idea\.$"
      regexp="y"
      name="d"
		enabled="y"
		group="consider"
		script="scan_trigger_right_here_mob"
		sequence="100"
      omit_from_output="y"
		omit_from_log="y"
	></trigger>
   
	<trigger match="^(?:\(.*\) )?(?<mob>.+) should be a fair fight\!$"
      regexp="y"
      name="e"
		enabled="y"
		group="consider"
		script="scan_trigger_right_here_mob"
		sequence="100"
      omit_from_output="y"
		omit_from_log="y"
	></trigger>
   
	<trigger match="^(?:\(.*\) )?(?<mob>.+) snickers nervously\.$"
      regexp="y"
      name="f"
		enabled="y"
		group="consider"
		script="scan_trigger_right_here_mob"
		sequence="100"
      omit_from_output="y"
		omit_from_log="y"
	></trigger>
   
	<trigger match="^(?:\(.*\) )?(?<mob>.+) chuckles at the thought of you fighting \b.+\b\.$"
      regexp="y"
      name="g"
		enabled="y"
		group="consider"
		script="scan_trigger_right_here_mob"
		sequence="100"
      omit_from_output="y"
		omit_from_log="y"
	></trigger>
   
	<trigger match="^(?:\(.*\) )?Best run away from (?<mob>.+) while you can\!$"
      regexp="y"
      name="h"
		enabled="y"
		group="consider"
		script="scan_trigger_right_here_mob"
		sequence="100"
      omit_from_output="y"
		omit_from_log="y"
	></trigger>
   
	<trigger match="^(?:\(.*\) )?Challenging (?<mob>.+) would be either very brave or very stupid\.$"
      regexp="y"
      name="i"
		enabled="y"
		group="consider"
		script="scan_trigger_right_here_mob"
		sequence="100"
      omit_from_output="y"
		omit_from_log="y"
	></trigger>
   
	<trigger match="^(?:\(.*\) )?(?<mob>.+) would crush you like a bug\!$"
      regexp="y"
      name="j"
		enabled="y"
		group="consider"
		script="scan_trigger_right_here_mob"
		sequence="100"
      omit_from_output="y"
		omit_from_log="y"
	></trigger>
   
	<trigger match="^(?:\(.*\) )?(?<mob>.+) would dance on your grave\!$"
      regexp="y"
      name="k"
		enabled="y"
		group="consider"
		script="scan_trigger_right_here_mob"
		sequence="100"
      omit_from_output="y"
		omit_from_log="y"
	></trigger>
   
	<trigger match="^(?:\(.*\) )?(?<mob>.+) says 'BEGONE FROM MY SIGHT unworthy\!'$"
      regexp="y"
      name="l"
		enabled="y"
		group="consider"
		script="scan_trigger_right_here_mob"
		sequence="100"
      omit_from_output="y"
		omit_from_log="y"
	></trigger>
   
	<trigger match="^(?:\(.*\) )?You would be completely annihilated by (?<mob>.+)\!$"
      regexp="y"
      name="m"
		enabled="y"
		group="consider"
		script="scan_trigger_right_here_mob"
		sequence="100"
      omit_from_output="y"
		omit_from_log="y"
	></trigger>

	<!-- who player cleansing -->
	<trigger
		name="trg_who_trigger"
		enabled="n"
		match="^\[.{15}\] (?:\*AFK\* |\[[^\]]+\] |\([^\)]+\) )*([^ ]+) .+$"
		regexp="y"
		script="logPlayer"
		sequence="100"
	></trigger>

	<trigger
		name="trg_who_end_trigger"
		enabled="n"
		match="^Players found\: \[[^\]]+\]\, Max this reboot\: \[[^\]]+\]\, Connections this reboot\: \[[^\]]+\]$"
		regexp="y"
		script="cleanupPlayers"
		sequence="100"
	></trigger>
	
	<!-- mob find -->

	<trigger
		name="trg_end_hunt_lookup"
		enabled="y"
		match="^No one in this area by that name\.$"
		regexp="y"
		script="end_hunt_lookup"
		sequence="100"
		keep_evaluating="y"
	></trigger>	
   
   <trigger
   name="trg_end_con"
   enabled="n"
   match="^$"
   regexp="y"
   sequence="100"
   script="end_con_all"
  >
  </trigger>
  <trigger
   name="trg_end_scan"
   enabled="n"
   match="^$"
   regexp="y"
   sequence="100"
   script="end_scan"
  >
  </trigger>
  <trigger
   name="trg_end_con2"
   enabled="n"
   match="^You see no one here but yourself!$"
   regexp="y"
   sequence="100"
   script="end_con_all"
  >
  </trigger>
  <trigger
   match="^You currently display ([0-9]+) lines per page\.|You do not page long messages\.$"
   name="trg_page_size"
   enabled="n"
   regexp="y"
   sequence="100"
   script="capture_page_size"
   omit_from_output = "y"
   keep_evaluating="y"		
	>
	</trigger>
  <trigger
   match="^Paging disabled\.|Page size set to .+ lines\.$"
   name="event_paging_disabled"
   enabled="n"
   regexp="y"
   sequence="100"
   send_to="12"
   omit_from_output = "y"
   keep_evaluating="y"		
	>
   <send>
      SendNoEcho("areas 0 298")
      EnableTrigger("event_paging_disabled", false)
   </send>
  </trigger>
  <trigger
   match="^Page size set to .+ lines\.$"
   name="event_paging_set"
   enabled="n"
   regexp="y"
   sequence="100"
   send_to="12"
   omit_from_output = "y"
   keep_evaluating="y"		
	>
   <send>
      EnableTrigger("event_paging_set", false)
   </send>
	</trigger>
  <trigger
   match="^Use \'pagesize <lines>\' to change, or \'pagesize 0\' to disable paging\.$"
   name="trg_page_size2"
   enabled="n"
   regexp="y"
   sequence="100"
   send_to="12"
   omit_from_output = "y"
   keep_evaluating="y"		
	>
   <send>
      EnableTrigger("trg_page_size2", false)
   </send>
	</trigger>
</triggers>

<script>

<![CDATA[

	require "serialize"
	require "gmcphelper"
	require "tprint"
   require "socket"
   
	local dbPath = GetPluginInfo(GetPluginID(), 20) .. "WinkleGold_Database.db"
   
	-- Variables --
	
	local search_destroy_id = "e50b1d08a0cfc0ee9c442001"
   local gui_id = "3f498d929793c12cb70f5999"
	local vi_assist_id = "6000a4c6f0e71d31fecf523d"
	local soundpack_id = "23832d1089f727f5f34abad8"
   local mapper_id = "b6eae87ccedd84f510b74714"

	local searchResult = {}
	local searchIndex = 0

	local cpList = {}
   local xcpData = {}
   local last_cpList = {}
   local last_xcpListItem = {}
	local cpIndex = 1
	local silentCheck = false

	local mode = "cp"
	local gotoList = {}
	local gotoIndex = 1
	
   local char_status = {}
   
   --move these to an init function later
   local currentRoom = {}

   
   if gmcp("room.info") ~= nil and type(gmcp("room.info")) ~= "string" then
      currentRoom = gmcp("room.info")
   end
   if gmcp("room.info.num") ~= nil then
      currentRoom.roomid = gmcp("room.info.num")
   end
   if gmcp("room.info.zone") ~= nil then
      currentRoom.areaid = gmcp("room.info.zone")
   end
   if gmcp("char.status") ~= nil and type(gmcp("char.status")) ~= "string" then
      char_status = gmcp("char.status")
   end
   local playerInfo = {}
   local questInfo = {}
   
   playerInfo.mayTakeCP = true
   areaRequestQueued = false

   local areaNames = {}

	local next_room = -1
	local last_area = ""

	local lastRoomId = -10

	local mapper_area_index = 0
	
	local sqlQueue = {}

	local last_substitute
	
	local speed = "run"

	-- Settings that are saved in plugin state files
	local setting_showPK
	local setting_autoScan
   local setting_autoCon
	local setting_startRooms
	local setting_areasIndex
	local setting_lastAreaCheck
	local setting_reduceSpam
	local setting_silentMode
	local setting_viMode
	local setting_debug
   local setting_noexp
   local setting_roomid
	local setting_vidblainHack
	local scanComplete = false
   local xcpInProgress = false
   
   local lastCpType
   local lastGqType
		
	local init_called = false

	local area_range = {}
	local areaStartRooms = {}
	
	local gqList = {}
   local last_gqList = {}
   local last_gqListItem = {}
	local gqIndex = 1
	local mapperconfig = {}
   
	AcceleratorTo("Alt + F", "accel_xcp_xgq()", sendto.script)
	AcceleratorTo("Alt + G", "accel_nx()", sendto.script)
	
   if (IsPluginInstalled(mapper_id) and GetPluginInfo(mapper_id, 17)) then
      --this loads the settings from the gmcp mapper   
      local mapper_config_str = GetPluginVariable(mapper_id, "configs")
      if mapper_config_str ~= nil then
         load(mapper_config_str)()
      end      
   end
   
	if not (IsPluginInstalled(vi_assist_id) and GetPluginInfo(vi_assist_id, 17)) then
   
		for i = 1, 9 do
			AcceleratorTo("Alt + " .. i, "accel_xcp_xgq(" .. i .. ")", sendto.script)
		end
	end

	local areaDefaultStartRooms = {		
		["aardington"] = { roomid = "47509", areaname = "Aardington Estate" },			-- A --
		["academy"] = { roomid = "35233", areaname = "Academy" },
		["adaldar"] = { roomid = "34400", areaname = "Battlefields of Adaldar" },
		["afterglow"] = { roomid = "38134", areaname = "Afterglow" },
		["agroth"] = { roomid = "11027", areaname = "Marshlands of Agroth" },
		["ahner"] = { roomid = "30129", areaname = "Kingdom of Ahner" },
		["alehouse"] = { roomid = "885", areaname = "Wayward Alehouse" },
		["amazon"] = { roomid = "1409", areaname = "Amazon Nation" },
		["amusement"] = { roomid = "29282", areaname = "Amusement Park" },
		["andarin"] = { roomid = "2399", areaname = "Blighted Tundra of Andarin" },
		["annwn"] = { roomid = "28963", areaname = "Annwn" },
		["anthrox"] = { roomid = "3993", areaname = "Anthrox" },
		["arena"] = { roomid = "25768", areaname = "Gladiator's Arena" },
		["arisian"] = { roomid = "28144", areaname = "Arisian Realm" },
		["ascent"] = { roomid = "43161", areaname = "First Ascent" },
		["astral"] = { roomid = "27882", areaname = "Astral Travels" },
		["atlantis"] = { roomid = "10573", areaname = "Atlantis" },
		["autumn"] = { roomid = "13839", areaname = "Eternal Autumn" },
		["avian"] = { roomid = "4334", areaname = "Avian Kingdom" },
		["aylor"] = { roomid = "32418", areaname = "Grand City Aylor" },
		["badtrip"] = { roomid = "32877", areaname = "Bad Trip" },						-- B --
		["bazaar"] = { roomid = "34454", areaname = "Onyx Bazaar" },
		["beer"] = { roomid = "20062", areaname = "Land of Beer Goblins" },
		["believer"] = { roomid = "25940", areaname = "Path of the Believer" },
		["blackrose"] = { roomid = "1817", areaname = "Black Rose" },
		["bliss"] = { roomid = "29988", areaname = "Wedded Bliss" },
		["caldera"] = { roomid = "26341", areaname = "Icy Caldera Mauldoon" },			-- C --
		["callhero"] = { roomid = "33031", areaname = "Call of Heroes" },
		["camps"] = { roomid = "4714", areaname = "Tournament Camps" },
		["canyon"] = { roomid = "25551", areaname = "Canyon Memorial Hospital" },
		["caravan"] = { roomid = "16071", areaname = "Gypsy Caravan" },
		["cards"] = { roomid = "6255", areaname = "House of Cards" },
		["carnivale"] = { roomid = "28635", areaname = "Olde Worlde Carnivale" },
		["cataclysm"] = { roomid = "19976", areaname = "Cataclysm" },
		["cathedral"] = { roomid = "27497", areaname = "Old Cathedral" },
		["cats"] = { roomid = "40900", areaname = "Sheila's Cat Sanctuary" },
		["chasm"] = { roomid = "29446", areaname = "Chasm and Catacombs" },
		["chessboard"] = { roomid = "25513", areaname = "Chessboard" },
		["childsplay"] = { roomid = "678", areaname = "Child's Play" },
		["cineko"] = { roomid = "1507", areaname = "Aerial City of Cineko" },
		["citadel"] = { roomid = "14963", areaname = "Flying Citadel" },
		["conflict"] = { roomid = "27711", areaname = "Thandeld's Conflict" },
		["coral"] = { roomid = "4565", areaname = "Coral Kingdom" },
		["cougarian"] = { roomid = "14311", areaname = "Cougarian Queendom" },
		["cove"] = { roomid = "49941", areaname = "Kiksaadi Cove" },
		["cradle"] = { roomid = "11267", areaname = "Cradlebrook" },
		["crynn"] = { roomid = "43800", areaname = "Crynn's Church" },
		["damned"] = { roomid = "10469", areaname = "Halls of the Damned" },			-- D --
		["darklight"] = { roomid = "19642", areaname = "Darklight" },
		["darkside"] = { roomid = "15060", areaname = "Darkside Fractured Lands" },
		["ddoom"] = { roomid = "4193", areaname = "Desert Doom" },
		["deadlights"] = { roomid = "16856", areaname = "Deadlights" },
		["deathtrap"] = { roomid = "1767", areaname = "Deathtrap Dungeon" },
		["deneria"] = { roomid = "35006", areaname = "Realm of Deneria" },
		["desert"] = { roomid = "20186", areaname = "Desert Prison" },
		["desolation"] = { roomid = "19532", areaname = "Mountains of Desolation MoD" },
		["dhalgora"] = { roomid = "16755", areaname = "Dhal'Gora Outlands" },
		["diatz"] = { roomid = "1254", areaname = "Three Pillars Diatz" },	
		["diner"] = { roomid = "36700", areaname = "Tumari's Diner" },
		["dortmund"] = { roomid = "16577", areaname = "Dortmund" },
		["drageran"] = { roomid = "25894", areaname = "Drageran Empire" },
		["dread"] = { roomid = "26075", areaname = "Dread Tower" },
		["dsr"] = { roomid = "30030", areaname = "Diamond Soul Revelation" },
		["dundoom"] = { roomid = "25661", areaname = "Dungeon Doom" },
		["dunoir"] = { roomid = "14222", areaname = "Mount DuNoir" },
		["duskvalley"] = { roomid = "37301", areaname = "Dusk Valley" },
		["dynasty"] = { roomid = "30799", areaname = "Eighteenth 18th Dynasty" },
		["earthlords"] = { roomid = "42000", areaname = "Earth Lords" },				-- E --
		["earthplane"] = { roomid = "1354", areaname = "Earth Plane 4" },
		["elemental"] = { roomid = "41624", areaname = "Elemental Chaos" },
		["empire"] = { roomid = "32203", areaname = "Empire of Aiighialla" },
		["empyrean"] = { roomid = "14042", areaname = "Empyrean Streets of Downfall" },
		["entropy"] = { roomid = "29773", areaname = "Archipelago Entropy" },
		["fantasy"] = { roomid = "15205", areaname = "Fantasy Fields" },				-- F --
		["farm"] = { roomid = "10676", areaname = "Kimr's Farm" },
		["fayke"] = { roomid = "30418", areaname = "All in Fayke Day" },
		["fens"] = { roomid = "16528", areaname = "Curse Midnight Fens" },
		["fields"] = { roomid = "29232", areaname = "Killing Fields" },
		["firebird"] = { roomid = "32885", areaname = "Realm of the Firebird" },
		["firenation"] = { roomid = "41879", areaname = "Realm of the Sacred Flame" },
		["fireswamp"] = { roomid = "34755", areaname = "Fire Swamp" },
		["fortress"] = { roomid = "31835", areaname = "Goblin Fortress" },
		["fractured"] = { roomid = "17033", areaname = "Fractured Lands" },
		["ft1"] = { roomid = "1205", areaname = "Faerie Tales" },
		["ftii"] = { roomid = "26673", areaname = "Faerie Tales II FT2" },
		["gallows"] = { roomid = "4344", areaname = "Gallows Hill" },					-- G --
		["gathering"] = { roomid = "36451", areaname = "Gathering Horde" },
		["gauntlet"] = { roomid = "31652", areaname = "Gauntlet" },
		["gilda"] = { roomid = "4243", areaname = "Gilda and the Dragon" },
		["glamdursil"] = { roomid = "35055", areaname = "Glamdursil" },
		["glimmerdim"] = { roomid = "26252", areaname = "Brightsea Glimmerdim" },
		["gnomalin"] = { roomid = "34397", areaname = "Cloud City of Gnomalin" },
		["goldrush"] = { roomid = "15014", areaname = "Gold Rush" },
		["graveyard"] = { roomid = "28918", areaname = "Graveyard" },
		["greece"] = { roomid = "2089", areaname = "Ancient Greece" },
		["gwillim"] = { roomid = "25974", areaname = "Trouble with Gwillimberry" },
		["hatchling"] = { roomid = "34670", areaname = "Hatchling Aerie" },				-- H --
		["hawklord"] = { roomid = "40550", areaname = "Realm of the Hawklords" },
		["hedge"] = { roomid = "15146", areaname = "Hedgehog's" },
		["helegear"] = { roomid = "30699", areaname = "Helegear Sea" },
		["hell"] = { roomid = "30984", areaname = "Descent to Hell" },
		["hoard"] = { roomid = "1675", areaname = "Swordbreaker's Hoard" },
		["hodgepodge"] = { roomid = "30469", areaname = "Magical Hodgepodge" },
		["horath"] = { roomid = "91", areaname = "Broken Halls of Horath" },
		["horizon"] = { roomid = "31959", areaname = "Nebulous Horizon" },
		["icefall"] = { roomid = "38701", areaname = "Icefall" },						-- I
		["illoria"] = { roomid = "10420", areaname = "Illoria" },
		["imagi"] = { roomid = "36800", areaname = "Imagi's Nation" },
		["imperial"] = { roomid = "16966", areaname = "Imperial Nation" },
		["infamy"] = { roomid = "26641", areaname = "Realm of Infamy" },
		["infest"] = { roomid = "16165", areaname = "Infestation" },
		["insan"] = { roomid = "6850", areaname = "Insanitaria" },
		["jenny"] = { roomid = "29637", areaname = "Jenny's Tavern" },					-- J --
		["jotun"] = { roomid = "31508", areaname = "Jotunheim" },
		["kearvek"] = { roomid = "29722", areaname = "Keep of Kearvek" },				-- K --
		["kerofk"] = { roomid = "16405", areaname = "Kerofk" },
		["ketu"] = { roomid = "35114", areaname = "Ketu Uplands" },
		["kingsholm"] = { roomid = "27522", areaname = "Kingsholm" },
		["knossos"] = { roomid = "28193", areaname = "Great City of Knossos" },
		["kobaloi"] = { roomid = "10691", areaname = "Keep of the Kobaloi" },
		["kultiras"] = { roomid = "31161", areaname = "Kul Tiras" },
		["lab"] = { roomid = "28684", areaname = "Chaprenula's Laboratory" },			-- L --
		["labyrinth"] = { roomid = "31405", areaname = "Labyrinth" },
		["lagoon"] = { roomid = "30549", areaname = "Black Lagoon" },
		["landofoz"] = { roomid = "510", areaname = "Land of Oz" },
		["laym"] = { roomid = "6005", areaname = "Tai'rha Laym" },
		["legend"] = { roomid = "16224", areaname = "Land of Legend LoL" },
		["lemdagor"] = { roomid = "1966", areaname = "Storm Ships of Lem-Dagor" },
		["lidnesh"] = { roomid = "27995", areaname = "Forest of Li'Dnesh" },
		["livingmine"] = { roomid = "37008", areaname = "Living Mines of Dak'Tai" },
		["longnight"] = { roomid = "26367", areaname = "Into the Long Night" },
		["losttime"] = { roomid = "28584", areaname = "Island of Lost Time" },
		["lplanes"] = { roomid = "29364", areaname = "Lower Planes" },
		["maelstrom"] = { roomid = "38058", areaname = "Maelstrom" },					-- M --
		["manor"] = { roomid = "10621", areaname = "Death's Manor" },
		["masq"] = { roomid = "29840", areaname = "Masquerade Island" },
		["mayhem"] = { roomid = "1866", areaname = "Artificer's Mayhem" },
		["melody"] = { roomid = "14172", areaname = "Art of Melody" },
		["minos"] = { roomid = "20472", areaname = "Shadows of Minos" },
		["mistridge"] = { roomid = "4491", areaname = "Covenant of Mistridge" },
		["monastery"] = { roomid = "15756", areaname = "Monastery" },
		["mudwog"] = { roomid = "2347", areaname = "Mudwog's Swamp" },
		["nanjiki"] = { roomid = "11203", areaname = "Nanjiki Ruins" },					-- N --
		["necro"] = { roomid = "29922", areaname = "Necromancer's Guild" },
		["nenukon"] = { roomid = "31784", areaname = "Nenukon and the Far Country" },
		["newthalos"] = { roomid = "23853", areaname = "New Thalos" },
		["northstar"] = { roomid = "11127", areaname = "Northstar" },
		["nottingham"] = { roomid = "11077", areaname = "Nottingham" },
		["nulan"] = { roomid = "37900", areaname = "Plains of Nulan'Boar" },
		["nursing"] = { roomid = "31977", areaname = "Ascension Bluff Nursing Home" },
		["nynewoods"] = { roomid = "23562", areaname = "Nyne Woods" },
		["oceanpark"] = { roomid = "39600", areaname = "Ocean Adventure Park" },		-- O --
		["omentor"] = { roomid = "15579", areaname = "Witches of Omen Tor" },
		["origins"] = { roomid = "35900", areaname = "Tribal Origins" },
		["orlando"] = { roomid = "30331", areaname = "Hotel Orlando" },
		["paradise"] = { roomid = "29624", areaname = "Paradise Lost" },				-- P --
		["peninsula"] = { roomid = "35701", areaname = "Tairayden Peninsula" },
		["petstore"] = { roomid = "995", areaname = "Giant's Pet Store" },
		["pompeii"] = { roomid = "57", areaname = "Pompeii" },
		["promises"] = { roomid = "25819", areaname = "Foolish Promises" },
		["prosper"] = { roomid = "28268", areaname = "Prosper's Island" },
		["qong"] = { roomid = "16115", areaname = "Qong" },								-- Q --
		["quarry"] = { roomid = "23510", areaname = "Gnoll's Quarry" },
		["radiance"] = { roomid = "19805", areaname = "Radiance Woods" },
		["raga"] = { roomid = "19861", areaname = "Raganatittu" },						-- R --
		["raukora"] = { roomid = "6040", areaname = "Blood Opal of Rauko'ra" },
		["rebellion"] = { roomid = "10305", areaname = "Rebellion Nix" },
		["remcon"] = { roomid = "25837", areaname = "Reman Conspiracy" },
		["reme"] = { roomid = "32703", areaname = "City of Reme" },
		["rosewood"] = { roomid = "6901", areaname = "Rosewood Castle" },
		["ruins"] = { roomid = "16805", areaname = "Ruins of Diamond Reach" },
		["sagewood"] = { roomid = "28754", areaname = "Sagewood Grove" },				-- S --
		["sahuagin"] = { roomid = "34592", areaname = "Abyssal Caverns of Sahuagin" },
		["salt"] = { roomid = "4538", areaname = "Great Salt Flats" },
		["sanctity"] = { roomid = "10518", areaname = "Sanctity of Eternal Damnation" },
		["sanctum"] = { roomid = "15307", areaname = "The Blood Sanctum" },
		["sandcastle"] = { roomid = "37701", areaname = "Sho'aram Shoaram Castle in the Sand" },
		["sanguine"] = { roomid = "15436", areaname = "Sanguine Tavern" },
		["scarred"] = { roomid = "34036", areaname = "Scarred Lands" },
		["sendhian"] = { roomid = "20288", areaname = "Adventures in Sendhia" },
		["sennarre"] = { roomid = "15491", areaname = "Sen'narre Lake" },
		["shouggoth"] = { roomid = "34087", areaname = "Temple of Shouggoth" },
		["siege"] = { roomid = "43265", areaname = "Kobold Seige Camp KSC" },
		["sirens"] = { roomid = "16298", areaname = "Siren's Oasis Resort" },
		["slaughter"] = { roomid = "1601", areaname = "Slaughterhouse" },
		["snuckles"] = { roomid = "182", areaname = "Snuckles Village" },
		["soh"] = { roomid = "25611", areaname = "School of Horror SOH1" },
		["sohtwo"] = { roomid = "30752", areaname = "School of Horror SOH2" },
		["solan"] = { roomid = "23713", areaname = "Town of Solan" },
		["songpalace"] = { roomid = "47013", areaname = "Palace of Song" },
		["spyreknow"] = { roomid = "34800", areaname = "Guardian's Spyre of Knowledge" },
		["stone"] = { roomid = "11386", areaname = "Fabled City of Stone" },
		["storm"] = { roomid = "6304", areaname = "Storm Mountain" },
		["stormhaven"] = { roomid = "20649", areaname = "Ruins of Stormhaven" },
		["stronghold"] = { roomid = "20572", areaname = "Dark Elf Stronghold DES" },
		["stuff"] = { roomid = "40400", areaname = "Stuff of Shadows" },
		["takeda"] = { roomid = "15952", areaname = "Takeda's Warcamp" },				-- T --
		["talsa"] = { roomid = "26917", areaname = "Empire of Talsa" },
		["temple"] = { roomid = "31597", areaname = "Temple of Shal'indrael" },
		["tanra"] = { roomid = "46913", areaname = "Tanra'vea" },
		["terra"] = { roomid = "19679", areaname = "Cracks of Terra" },
		["terramire"] = { roomid = "4493", areaname = "Fort Terramire" },
		["thieves"] = { roomid = "7", areaname = "Den of Thieves" },
		["times"] = { roomid = "28463", areaname = "Intrigues of Times Past" },
		["tirna"] = { roomid = "20136", areaname = "Tir na Nog" },
		["tol"] = { roomid = "16325", areaname = "Tree of Life" },
		["tombs"] = { roomid = "15385", areaname = "Relinquished Tombs" },
		["umari"] = { roomid = "36601", areaname = "Umari's Castle" },					-- U --
		["underdark"] = { roomid = "27341", areaname = "Underdark" },
		["uplanes"] = { roomid = "29364", areaname = "Upper Planes" },
		["uprising"] = { roomid = "15382", areaname = "Uprising" },
		["vale"] = { roomid = "1036", areaname = "Sundered Vale" },						-- V --
		["verdure"] = { roomid = "24090", areaname = "Verdure Estate" },
		["verume"] = { roomid = "30607", areaname = "Jungles of Verume" },
		["village"] = { roomid = "30850", areaname = "Peaceful Giant Village" },
		["vlad"] = { roomid = "15970", areaname = "Vlad Shamir" },
		["volcano"] = { roomid = "6091", areaname = "Silver Volcano" },
		["weather"] = { roomid = "40499", areaname = "Weather Observatory" },			-- W --
		["werewood"] = { roomid = "30956", areaname = "Were Wood" },
		["wildwood"] = { roomid = "322", areaname = "Wildwood" },
		["winter"] = { roomid = "1306", areaname = "Winterlands" },
		["wizards"] = { roomid = "31316", areaname = "War of the Wizards WoW" },
		["wonders"] = { roomid = "32981", areaname = "Seven Wonders" },
		["wooble"] = { roomid = "11335", areaname = "Wobbly Woes of Woobleville" },
		["woodelves"] = { roomid = "32199", areaname = "Wood Elves of Nalondir" },
		["wtc"] = { roomid = "37895", areaname = "Warrior Training Camp WTC" },
		["wyrm"] = { roomid = "28847", areaname = "Council of the Wyrm" },
		["xmas"] = { roomid = "6212", areaname = "Christmas Vacation" },				-- X --
		["xylmos"] = { roomid = "472", areaname = "Xyl's Mosaic" },
		["yarr"] = { roomid = "30281", areaname = "Misty Shores of Yarr" },				-- Y --
		["ygg"] = { roomid = "24186", areaname = "Yggdrasil: The World Tree" },
		["yurgach"] = { roomid = "29450", areaname = "Yurgach Domain" },
		["zangar"] = { roomid = "6164", areaname = "Zangar's Demonic Grotto" },			-- Z --
		["zodiac"] = { roomid = "15857", areaname = "Realm of the Zodiac" },
		["zoo"] = { roomid = "5920", areaname = "Aardwolf Zoological Park" },
		["zyian"] = { roomid = "729", areaname = "Dark Temple of Zyian" },
	}

	function init_plugin()
      areaNames = listAreas()
      SendNoEcho("tags scan on")
      Send_GMCP_Packet("request char")
      Send_GMCP_Packet("request quest")
      Send_GMCP_Packet("config noexp")
      load_bounce()
		
      if area_range ~= nil and tablelength(area_range) > 0 then
         DebugNote(tablelength(area_range) .. " areas indexes loaded successfully from saved table.")
      else
         DebugNote("Areas indexes failed to load.. queueing an xareas re-index ASAP!")
         get_area_index()
      end

		if setting_lastAreaCheck == nil then
			DebugNote("No saved area list information found yet, requesting..")
			get_area_index()
		elseif (os.time() - setting_lastAreaCheck) > 604800 then -- if it's been longer than a week since we updated areas table
			DebugNote("Outdated saved area list information, requesting a new list..")
			get_area_index()
		end
      xcp_flag = true
      DebugNote("Requesting initial gmcp char info and cp listing..")
      DoAfterSpecial(2, 'silent_check_cp()', 12) -- get the cp list initially on load
	end

		local get_start_areas_sql =  
		"SELECT r.uid, r.name as room, a.name as area, a.uid as areaid " ..
		"FROM rooms r " ..
		"INNER JOIN areas a ON a.uid = r.area " ..
		"WHERE a.uid like %s " ..
		"ORDER BY r.date_added ASC, r.name "
			
	function check_old_starts()
		_10=pairs function _1(_6)local _2={}for _4 in _10(_6)do table.insert(_2,_4)end table.sort(_2)return _2 end function _3(_6,_5)if _5==nil then _6._7=_1(_6)_4=_6._7[1]return _4,_6[_4]end _4=nil for _8 = 1,table.getn(_6._7)do if _6._7[_8]==_5 then _4=_6._7[_8+1]end end if _4 then return _4,_6[_4]end _6._7=nil return end function _9(_6)return _3,_6,nil end pairs=_9
		--this checks ancient databases for setstarts using the old date_added method
		local areas = {}
		local db
		local worldPath = GetInfo(66)..Trim(sanitize_filename(WorldName()))
		local db = assert(sqlite3.open(worldPath .. ".db"))
		print("Checking database for old setstarts and importing.")
		if dbColumnExists(db, "rooms", "date_added") then
		
		areas = listAreas()
			for key, val in pairs(areas) do
				--print(key)
				local select = string.format (get_start_areas_sql, fixsql(key))
				
				for row in db:nrows(select) do
				if string.find(row.uid, "nomap") ~= nil then break end -- skip nomap entries
				print("[" .. key .. "] Start Room: " .. row.uid .. " Area Name: " .. val.name)
				--areaStartRooms[key] = {
				areaStartRooms[key] = { areaname = val.name, roomid = row.uid }
				break
				
				end
			end
			
			SetVariable("areaStartRooms", serialize.save_simple(areaStartRooms))
			print("Saved areaStartRooms to disk.")
		else
			print("Nope..")
		end
		
	end
   
   function listAreas()

		local worldPath = GetInfo(66)..Trim(sanitize_filename(WorldName()))
		local db = assert(sqlite3.open(worldPath .. ".db"))

		local sql =  "SELECT uid, name FROM areas order by uid "

		local areas = {}
		--local index = 0
		
		for row in db:nrows(sql) do
			--DebugNote(row.uid)
			areas[row.uid] = {uid = row.uid, name = row.name}
		end
		
		db:close_vm()
		return areas
	end
   
   function ping(name, line, wc)
      pingStart = socket.gettime()*1000
      SendNoEcho("echo {PING}")
      EnableTrigger("trg_ping", true)
   end
   
   function pong(name, line, wc)
      EnableTrigger("trg_ping", false)
      local pingEnd = socket.gettime()*1000
      local pingMsg = "Current ping: " .. round(pingEnd - pingStart, 3) .. "ms"
      --print(pingMsg)
      ColourTell("darkorange", "", pingMsg)
      print("")
   end
   
	function get_area_index(name, line, wildcards)
		ColourNote("DarkOrange", "", "*** Indexing area levels...")
		EnableTrigger("event_paging_disabled", true)
		SetTriggerOption("event_paging_messages", "omit_from_log", "y")
		SetTriggerOption("event_paging_messages", "omit_from_output", "y")
		Execute("xset suspend page size")
		DebugNote("get_area_index() called")
		EnableTrigger("trg_area_index_start_gag", true)
		EnableTrigger("trg_area_index_start", true)
		EnableTrigger("trg_area_index_line", false)
		EnableTrigger("trg_area_index_end", true)
		EnableTrigger("trg_area_index_gag1", true)
		EnableTrigger("trg_area_index_gag2", true)
	end

	function OnPluginBroadcast (msg, id, name, text)

		-- Look for GMCP handler.
      if (id == 'e50b1d08a0cfc0ee9c442001') then
         if tonumber(msg) == 150 then
            questInfo = load( "return "..text)( )
            if questInfo.mobName ~= nil then DebugNote("Received quest mob: " .. questInfo.mobName) end
         end
      elseif id == mapper_id then
         if tonumber(msg) == 500 then
            --print(text)
            --print("500 happened")
         elseif tonumber(msg) == 501 then
            --print(text)
            --print("501 happened")
         end
		elseif (id == '3e7dedbe37e44942dd46d264') then
         if (text == "char.vitals") then
         
         elseif (text == "char.base") then
            if not init_called then
               init_plugin()
               init_called = true
            end
            playerInfo.tier = tonumber(gmcp("char.base.tier"))

         elseif (text == "char.status") then
            playerInfo.current_tnl = tonumber(gmcp("char.status.tnl"))
            char_status = gmcp("char.status")
            playerInfo.level = tonumber(gmcp("char.status.level"))
            --print("Level is " .. char_status.level)
            
            if setting_noexp == 0 then return end
            
            if playerInfo.current_tnl < setting_noexp then
               if playerInfo.mayTakeCP then
                  if not playerInfo.noexp_enabled then
                     SendNoEcho("noexp")
                     playerInfo.noexp_enabled = true
                  end
               elseif not playerInfo.mayTakeCP then
                  if playerInfo.noexp_enabled then
                     SendNoEcho("noexp")
                     playerInfo.noexp_enabled = false
                  end
               end
            end

         elseif (text == "config") then
         
            local noexp_val = gmcp("config.noexp")
            if noexp_val == nil then return end
            local textStr = ""
            if noexp_val == "NO" then
               playerInfo.noexp_enabled = false
               --textStr = "Noexp is currently disabled."
            elseif noexp_val == "YES" then
               playerInfo.noexp_enabled = true
               textStr = "Noexp is currently enabled. Threshold is set to " .. setting_noexp .. " exp."
               ColourNote("darkorange", "", textStr)
               if (IsPluginInstalled(vi_assist_id) and GetPluginInfo(vi_assist_id, 17)) then
                     local rc = CallPlugin(vi_assist_id, "review_addline", "All", textStr)
               end
            end

			elseif (text == "room.info") then
            if not init_called then
               init_plugin()
               init_called = true
            end
            local tmpAreaName = currentRoom.areaname
            
            if (currentRoom.areaid ~= gmcp("room.info.zone")) then
               currentRoom.areaid = gmcp("room.info.zone")
               if char_status.state ~= nil then
                  if char_status.state ~= "12" and areaRequestQueued then
                     Send_GMCP_Packet("request area")
                     currentRoom = gmcp("room.info")
                     currentRoom.areaname = tmpAreaName
                     currentRoom.roomname = gmcp("room.info.name")
                     currentRoom.roomid = gmcp("room.info.num")
                     currentRoom.areaid = gmcp("room.info.zone")  
                     return
                  end
                  if char_status.state == "12" then
                     areaRequestQueued = true
                  else
                     Send_GMCP_Packet("request area")
                  end
               end
            end
            
            if currentRoom.areaname ~= nil then
               tmpAreaName = currentRoom.areaname
            end
            currentRoom = gmcp("room.info")
            currentRoom.areaname = tmpAreaName
            currentRoom.roomid = gmcp("room.info.num")
            currentRoom.areaid = gmcp("room.info.zone")            
            if playerInfo.destRoom and playerInfo.destRoom == tonumber(currentRoom.roomid) then
               playerInfo.destRoom = nil
               if setting_autoScan == "1" then
                  SendNoEcho("scan here")
               elseif setting_autoCon == "1" then
                  playerInfo.conInProgress = true
                  EnableTrigger("trg_end_con2", true)
                  SendNoEcho("con all")
               end
            end
            if setting_roomid == "1" then
               Hyperlink("xrt " .. currentRoom.areaid, "[ Area: " .. currentRoom.areaid .. ",", "xrt " .. currentRoom.areaid, "LightSeaGreen", "black", 0, 1)
               Hyperlink("xpath " .. currentRoom.roomid, " " .. currentRoom.roomid .. " ]", "xrt " .. currentRoom.roomid, "LightSeaGreen", "black", 0, 1)
               print("")
            end
            	
         elseif (text == "char.vitals") then
            if not initialized then
               initialized = true
               init_plugin()
            end
            
			elseif (text == "room.area") then
				res, gmcparg = CallPlugin("3e7dedbe37e44942dd46d264","gmcpval","room.area")
				luastmt = "gmcpdata = " .. gmcparg
				assert (loadstring (luastmt or "")) ()
				currentRoom.areaname = gmcpval("name")
			end
		end
	end
	
	function accel_nx(name, line, wc)
		Execute("nx")
	end
	
	function accel_xcp_xgq(indexNum)
		
		if (IsPluginInstalled(vi_assist_id) and GetPluginInfo(vi_assist_id, 17)) then
			-- vi plugin detected let's find out what they have selected
			local rc, currCat, currMsg, currLen = CallPlugin (vi_assist_id, "get_current_selection")
			--if currMsg == nil then print("currmsg nil") end
			--if currCat == nil then print("currcat nil") end
			--if currLen == nil then print("currlen nil") end
			if currMsg and currCat then
				DebugNote("cplist is " .. #cpList)
				DebugNote("currMsg = " .. currMsg)
				DebugNote("currCat = " .. currCat)
				
				--local index = currLen - currMsg + 1
				if currMsg == 0 then index = 1 end
				--if currMsg > currLen then currLen = currMsg end
				
				
				if currCat == "GQ" then
					if gqList == nil then
						ColourNote("darkorange", "", "No global quest targets found.")
						return
					end
					currLen = #gqList
					index = #gqList - currMsg + 1
					DebugNote("Changed xgq index length to " .. #gqList)
					if index < 1 then index = 1 end
					if gqList[index] ~= nil then
						DebugNote("qqing to target " .. gqList[index].mob)
						Execute("qq " .. index)
					else
						ColourNote("darkorange", "", "No global quest targets found.")
					end
				elseif currCat == "CP" then
					if cpList == nil then
						ColourNote("darkorange", "", "No campaign targets found.")
						return
					end
					currLen = #cpList
					index = #cpList - currMsg + 1
					DebugNote("Changed xcp index length to " .. #cpList)
					if index < 1 then index = 1 end
					if cpList[index] ~= nil then
						DebugNote("xcping to target " .. cpList[index].mob)
						Execute("xcp " .. index)
					else
						ColourNote("darkorange", "", "No campaign targets found.")
					end
				else
					if cpList[1] ~= nil then
						DebugNote("xcping to target " .. cpList[1].mob)
						Execute("xcp 1")
					else
						ColourNote("darkorange", "", "No campaign targets found.")
					end
				end
			end
		return
		end
		
		if indexNum == nil then indexNum = 1 end
		
		if mode == "gq" then
			Execute("qq " .. indexNum)
		else
			Execute("xcp " .. indexNum)
		end
	end
	
   function event_cp_mob_dead(name, line, wc)
		if mode ~= "gq" then
         Execute("cp c")
         BroadcastPlugin(680, "0")
      end     
   end
   
   function event_player_level(name, line, wc)
   if setting_noexp == 0 then return end
      playerInfo.mayTakeCP = true
      --if playerInfo.noexp_enabled then
         --playerInfo.noexp_enabled = false
         --SendNoEcho("noexp")
      --end
      --print("Level raise detected " .. wc[1])
   end
   
   
   function event_noexp_on(name, line, wc)
      if setting_noexp == 0 then return end
      playerInfo.noexp_enabled = true
   end
   
   function event_noexp_off(name, line, wc)
      if setting_noexp == 0 then return end
      playerInfo.noexp_enabled = false
   end
   
	function set_speed(name, line, wildcards)
		if (wildcards.speed ~= "") then
			speed = wildcards.speed
		else
			if (speed == "walk") then
				speed = "run"
			else
				speed = "walk"
			end
		end
		ColourNote("darkorange", "", "Move speed:" .. speed)
	end

	function set_noexp(name, line, wc)
      if wc.value ~= nil then
         setting_noexp = tonumber(wc.value)
         if setting_noexp == 0 then
            print("")
            ColourNote("darkorange", "", "Auto-noexp threshold has been disabled.")
               if playerInfo.noexp_enabled then
                  playerInfo.noexp_enabled = false
                  SendNoEcho("noexp")
                  --Send_GMCP_Packet("config noexp off")
               end
            
            print("")            
         else
            print("")
            ColourNote("darkorange", "", "Auto-noexp threshold has been set to " .. wc.value .. " exp.")
            if playerInfo.current_tnl ~= nil then
               if playerInfo.current_tnl > setting_noexp then
                  if playerInfo.noexp_enabled then
                     playerInfo.noexp_enabled = false
                     SendNoEcho("noexp")
                  end
                  --Send_GMCP_Packet("config noexp off")
               elseif playerInfo.current_tnl <= setting_noexp then
                  if not playerInfo.noexp_enabled then
                     playerInfo.noexp_enabled = true
                     SendNoEcho("noexp")
                  end
               end
            end
            print("")
         end
      else
         if setting_noexp > 0 then
            print("")
            ColourNote("darkorange", "", "Auto-noexp is currently set to " .. tostring(setting_noexp) .. " exp.")
            print("")
         else
            print("")
            ColourNote("darkorange", "", "Auto-noexp threshold has not yet been set. Type xset noexp <amount> to set it.")
            print("")
         end
      end
	end	

	function move_trigger(name, line, wildcards)
		
		if (wildcards.roomid ~= "") then
			move(wildcards.roomid, wildcards.speed)
		end
		
	end
	
	function move(roomid, temp_speed)
	
		if (temp_speed == nil or temp_speed == "") then
			temp_speed = speed
		end
		if (temp_speed == "walk") then
			Note("walking to " .. roomid)
			Execute("mapper walkto " .. roomid)
		else
			Execute("xpath " .. roomid)
		end
	end
	
	local last_cp_check = os.time()
	
	function xcp_check(name, line, wildcards)
		DebugNote("xcp_check")
		
		xcp_flag = true

		-- prevent double cp checks from different plugins
		--local time_check = os.time()
		--if ((time_check - last_cp_check) < 2) then
		--	return
		--end
		--last_cp_check = time_check

		EnableTrigger("trg_xcp_line", true)
		EnableTrigger("trg_xcp_line_end", false)
		
		if (wildcards.param == "test") then
         cpList = {}
         cpIndex = 1
			cp_simulate()
		else
			if setting_silentMode == "1" then
            if string.sub(line, 1, 3) ~= "xcp" then
               silent_check_cp()
            else
               xcpData = {}
               cpList = {}
               cpIndex = 1
               SendNoEcho("cp c")
            end
			else
            xcpData = {}
            cpList = {}
            cpIndex = 1
				SendNoEcho("cp c")
			end
		end
	end
	
	function silent_check_cp(name, line, wildcards)
      xcp_flag = true
      cpList = {}
      xcpData = {}
		cpIndex = 1
		silentCheck = true
		EnableTrigger("trg_cp_check_note_scrambled", true)
		SetTriggerOption("trg_xcp_line", "omit_from_output", "1")
		SetTriggerOption("trg_xcp_line", "omit_from_log", "1")
      SetTriggerOption("trg_xcp_must_level", "omit_from_output", "1")
      SetTriggerOption("trg_xcp_must_level", "omit_from_log", "1")
      SetTriggerOption("trg_xcp_may_take", "omit_from_output", "1")
      SetTriggerOption("trg_xcp_may_take", "omit_from_log", "1")
		EnableTrigger("trg_xcp_line", true)
		SendNoEcho("cp ch")
	end
	
	function silent_check_gq(name, line, wildcards)
		silentCheck = true
		
		EnableTrigger("trg_gq_check_note_scrambled", true)
		SetTriggerOption("trg_gq_check_note_scrambled", "omit_from_log", "y")
		SetTriggerOption("trg_gq_check_note_scrambled", "omit_from_output", "y")
		
		EnableTrigger("event_gq_note", true)
		SetTriggerOption("event_gq_note", "omit_from_log", "y")
		SetTriggerOption("event_gq_note", "omit_from_output", "y")
		
		SetTriggerOption("x_gq_line_end_none", "omit_from_log", "y")
		SetTriggerOption("x_gq_line_end_none", "omit_from_output", "y")
		
		SendNoEcho("gq ch")
	end
	
	function process_cp_check()
		DebugNote("process_cp_check()")
		silentCheck = false
		SetTriggerOption("trg_process_cp_check", "omit_from_output", "0")
		SetTriggerOption("trg_process_cp_check", "omit_from_log", "0")
		--EnableTrigger("trg_cp_check_note_scrambled", false)
		EnableTrigger("trg_process_cp_check", false)
		EnableTrigger("trg_xcp_line", false)
	end


	function xcp_index_line(name, line, wildcards)

		EnableTrigger("trg_xcp_line_end", true)

		if (cpList == nil) then
         xcpData = {}
			cpList = {}
			cpIndex = 1
		end
		
		DebugNote("xcp_index_line:" .. wildcards.mob)
      
      if xcpData["original"] == nil then
         xcpData["original"] = {}
      end
      table.insert(xcpData["original"], line)
      
		cpIndex = get_rooms_areas(cpList, cpIndex, wildcards.where, wildcards.mob, 1, wildcards.isdead)
		
		
		if silentCheck then
			EnableTrigger("trg_cp_check_note_scrambled", true)
			SetTriggerOption("trg_cp_check_note_scrambled", "omit_from_output", "1")
			SetTriggerOption("trg_cp_check_note_scrambled", "omit_from_log", "1")
			SetTriggerOption("trg_cp_check_note_dead", "omit_from_output", "1")
			SetTriggerOption("trg_cp_check_note_dead", "omit_from_log", "1")
		else
         SetTriggerOption("trg_xcp_must_level", "omit_from_output", "0")
         SetTriggerOption("trg_xcp_must_level", "omit_from_log", "0")
         SetTriggerOption("trg_xcp_may_take", "omit_from_output", "0")
         SetTriggerOption("trg_xcp_may_take", "omit_from_log", "0")
      end
	end
   
	function xcp_end(name, line, wildcards)
		EnableTrigger("trg_xcp_line", false)
		EnableTrigger("trg_xcp_line_end", false)
		
		if silentCheck then
			SetTriggerOption("trg_xcp_line", "omit_from_output", "1")
			SetTriggerOption("trg_xcp_line", "omit_from_log", "1")
			SetTriggerOption("trg_process_cp_check", "omit_from_output", "1")
			SetTriggerOption("trg_process_cp_check", "omit_from_log", "1")
			EnableTrigger("trg_process_cp_check", true)
         SetTriggerOption("trg_xcp_must_level", "omit_from_output", "1")
         SetTriggerOption("trg_xcp_must_level", "omit_from_log", "1")
			SetTriggerOption("trg_xcp_may_take", "omit_from_output", "1")
			SetTriggerOption("trg_xcp_may_take", "omit_from_log", "1")
			EnableTrigger("trg_xcp_may_take", true)
		else
			SetTriggerOption("trg_xcp_line", "omit_from_output", "1")
			SetTriggerOption("trg_xcp_line", "omit_from_log", "1")
         SetTriggerOption("trg_xcp_must_level", "omit_from_output", "0")
         SetTriggerOption("trg_xcp_must_level", "omit_from_log", "0")
			SetTriggerOption("trg_xcp_may_take", "omit_from_output", "0")
			SetTriggerOption("trg_xcp_may_take", "omit_from_log", "0")
			EnableTrigger("trg_xcp_line", true)
		end
		local list = {}
      last_cpList = {}
      xcpData = {}
      last_xcpListItem = {}
		local ser = serialize.save_simple(list)
		BroadcastPlugin(669, ser)
      
      if (IsPluginInstalled(vi_assist_id) and GetPluginInfo(vi_assist_id, 17)) then
			local rc = CallPlugin(vi_assist_id, "clear_list", "cp")
      end
		
	end
	
	function xcp_index_line_end(name, line, wildcards)
      if #cpList == 0 then
         cpList = last_cpList
      end
		DebugNote("xcp_index_line_end")

		EnableTrigger("trg_xcp_line", false)
		EnableTrigger("trg_xcp_line_end", false)
		
		if silentCheck then
			SetTriggerOption("trg_xcp_line", "omit_from_output", "1")
			SetTriggerOption("trg_xcp_line", "omit_from_log", "1")
			SetTriggerOption("trg_process_cp_check", "omit_from_output", "1")
			SetTriggerOption("trg_process_cp_check", "omit_from_log", "1")
			EnableTrigger("trg_process_cp_check", true)
			SetTriggerOption("trg_xcp_may_take", "omit_from_output", "1")
			SetTriggerOption("trg_xcp_may_take", "omit_from_log", "1")
			EnableTrigger("trg_xcp_may_take", true)
		else
			SetTriggerOption("trg_xcp_line", "omit_from_output", "1")
			SetTriggerOption("trg_xcp_line", "omit_from_log", "1")
			EnableTrigger("trg_xcp_line", true)
		end
      
		--if (xcp_flag == false) then
		--	return
		--end
		
		xcp_flag = false
      if cpList == nil then print("Something has cleared the cpList") return end
      --sort the list
      cpList = sort_list(cpList)
      
		if not silentCheck then
      --if setting_silentMode ~= "1" and not silentCheck then
         print_rooms_areas(cpList, "xcp")
		else
         cpList = filter_list(cpList)
		end
      last_cpList = cpList
		-- broadcast this data for other plugins to consume
		local ser = serialize.save_simple(cpList)
		BroadcastPlugin(669, ser)
      local xcp_ind = 0
      for i = 1, #cpList do
         if last_xcpListItem ~= nil and cpList[i].areaName == last_xcpListItem.areaName and cpList[i].mob == last_xcpListItem.mob then
            DebugNote("Found PERFECT match at " .. i)
            xcp_ind = i
         end
      end
      BroadcastPlugin(680, xcp_ind)
      
		mode = "cp"
		-- if the user has vi assist plugin installed, send the data directly into their CP buffer
		
		if (IsPluginInstalled(vi_assist_id) and GetPluginInfo(vi_assist_id, 17)) then
			local rc = CallPlugin(vi_assist_id, "clear_list", "cp")
         
			for index,value in ripairs(cpList) do
				local strListItem = ""
				if value.qty ~= nil and value.qty > 1 then strListItem = value.qty .. " " end
				strListItem = strListItem .. value.mob
				if value.roomName ~= "" and value.roomName ~= nil then
					strListItem = strListItem .. "; in room: " .. value.roomName
				end
				strListItem = strListItem .. "; in area: " .. value.areaId
					if (value.isDead ~= nil and value.isDead ~= "") then
						strListItem = strListItem .. " - Mob is dead!"
					end
					local rc = CallPlugin(vi_assist_id, "review_addline", "CP", strListItem)
			end
		end
	end
	
   function gq_joined(name, line, wc)
      playerInfo.gqNum = tonumber(wc.gqnum)
      playerInfo.levelTaken = tonumber(gmcp("char.status.level"))
      SaveState()
      silent_check_gq()
	end
   
   function gq_started(name, line, wc)
      if tonumber(wc.gqnum) == playerInfo.gqNum then
         Execute("qq")
      end
	end

   function gq_ended(name, line, wc)
      if tonumber(wc.gqnum) == playerInfo.gqNum then
         --make sure it's the gquest we are on that ended
         capture_gq_end()
      end
	end
   
	function xcp_cp_started(name, line, wc)
      playerInfo.levelTaken = tonumber(gmcp("char.status.level"))
      SaveState()
	end
	
   function xcp_must_level(name, line, wc)
      SetTriggerOption("trg_xcp_must_level", "omit_from_output", "0")
      SetTriggerOption("trg_xcp_must_level", "omit_from_log", "0")
      if setting_noexp == 0 then return end
      playerInfo.mayTakeCP = false
      if playerInfo.noexp_enabled then
         SendNoEcho("noexp")
         playerInfo.noexp_enabled = false
      end
         
   end
   
	function xcp_may_take(name, line, wc)
      SetTriggerOption("trg_xcp_may_take", "omit_from_output", "0")
      SetTriggerOption("trg_xcp_may_take", "omit_from_log", "0")
      if setting_noexp == 0 then return end
         playerInfo.mayTakeCP = true
      	--EnableTrigger("trg_xcp_may_take", false)
   end
	
	function xcp_note_scrambled(name, line, wc)
		DebugNote("xcp_note_scrambled")
		--SetTriggerOption("trg_cp_check_note_scrambled", "omit_from_output", "0")
		--SetTriggerOption("trg_cp_check_note_scrambled", "omit_from_log", "0")
		--EnableTrigger("trg_cp_check_note_scrambled", false)
	end
	
	function xcp_note_dead(name, line, wc)
		DebugNote("xcp_note_dead")
		SetTriggerOption("trg_cp_check_note_dead", "omit_from_output", "0")
		SetTriggerOption("trg_cp_check_note_dead", "omit_from_log", "0")
	end


	local get_rooms_areas_sql = 
		" SELECT r.uid as room, r.name as roomName, a.uid as area, a.name as areaName, 'room' as type, info " ..
		" FROM rooms r " ..
		" INNER JOIN areas a ON r.area = a.uid " ..
		" WHERE r.name = %s " ..
		" UNION " ..
		" SELECT -1 as room, '' as roomName, uid as area, name as areaName, 'area' as type, '' as info " ..
		" FROM areas " ..
		" WHERE name = %s " ..
		" ORDER BY type ASC "

	function get_rooms_areas(list, listIndex, place, mobName, qty, isDead)
      DebugNote("get_rooms_areas adding listIndex " .. listIndex .. " - " .. mobName)
		local localLevel = -1
		if (char_status == nil) then
			DebugNote("Unknown char status")
			return
		else
         localLevel = playerInfo.levelTaken
         --localLevel = 55
         -- just in case
		end
		
      if localLevel == nil then localLevel = tonumber(char_status.level) end
		local worldPath = GetInfo(66)..Trim(sanitize_filename(WorldName()))
		local db = assert(sqlite3.open(worldPath .. ".db"))

		-- find room/area
		local select = string.format (get_rooms_areas_sql, fixsql(place), fixsql(place))
		DebugNote(select)
		
		local index = 0
		local lastMobSignature = ""
		for row in db:nrows(select) do

			if (row.type == "room") then
			
				local tolerance = 11
				local min = (area_range[row.areaName] or {min = 0}).min 
				local max = (area_range[row.areaName] or {max = 300}).max
            if min == 0 and max == 300 then
               ColourNote("Red", "", "*** WARNING: areas index is missing for " .. row.areaName .. ", type \"xareas\" to re-index and report this to Pwar!")
            end
            
				-- debug
				--min = 0
				--max = 300

				-- filter out spammy neighbouring rooms.. too much spam!
				local mobSignature = row.areaName .. "|" .. mobName
				local showItem = false
				DebugNote("lastMobSignature:" .. lastMobSignature .. ":mobSignature:" .. mobSignature)
				
				-- sanitize text room ids for "unmappable" rooms that are now being mapped
				
            row.room = (tonumber(row.room) or "nomap")
            
				if (lastMobSignature ~= mobSignature) then
					if (localLevel >= (min - tolerance) and localLevel <= (max + tolerance)) then
						--print(min - tolerance)
                  --print(max + tolerance)
						index = index + 1
				
						list[listIndex] = {
							qty = tonumber(qty),
							mob = mobName,
							type = row.type,
							roomId = row.room,
							roomName = row.roomName,
							areaId = row.area,
							areaName = row.areaName,
							area = row.area,
							isDead = isDead,
							min = min,
							max = max,
							info = row.info}

						listIndex = listIndex + 1
					else
                  local removed = {
							qty = tonumber(qty),
							mob = mobName,
							type = row.type,
							roomId = row.room,
							roomName = row.roomName,
							areaId = row.area,
							areaName = row.areaName,
							area = row.area,
							isDead = isDead,
							min = min,
							max = max,
							info = row.info,
                     removed_reason = "level"}
                  if xcpData["removed_guesses"] == nil then
                     xcpData["removed_guesses"] = {}
                  end
                  table.insert(xcpData["removed_guesses"], removed)
						if setting_reduceSpam ~= "1" then
							local link = string.format("Ignoring due to level : %s in '%s' (%s) [%s-%s]", mobName, row.roomName, row.area, min, max)
							Hyperlink("xm move " .. row.room, link, "Move to room " .. row.room, "Khaki", "black", 0, 1)
							print("")
						end
					end
				end
					
				lastRoomId = row.room
				lastMobSignature = mobSignature
				
			else -- area

				index = index + 1
			
				DebugNote("get_rooms_areas - area:" .. index .. ":" .. mobName)
            
				list[listIndex] = {
					qty = tonumber(qty),
					mob = mobName,
					type = row.type,
					roomId = row.room,
					roomName = row.roomName,
					areaId = row.area,
					areaName = row.areaName,
					area = row.area,
					isDead = isDead}

				listIndex = listIndex + 1
			
			end
		end
		db:close_vm()
		
		DebugNote(mobName .. " index:" .. index)
		-- add mobs
		if (index == 0) then
			list[listIndex] = {
				qty = tonumber(qty),
				mob = mobName,
				type = "unknown",
				roomId = 0,
				roomName = place,
				areaId = "UNKNOWN",
				areaName = "UNKNOWN",
				area = "UNKNOWN",
				isDead = isDead}

			listIndex = listIndex + 1	
		end
		return listIndex
	end
	
   function get_list_type(list)
      
      if #list < 7 then
         if mode == "gq" then
            return lastGqType
         elseif mode == "cp" then
            return lastCpType
         end
      end
      local roomscount = 0
      local areascount = 0
      for k, v in ipairs(list) do
         if v.type == "area" then
				areascount = areascount + 1
			elseif v.type =="room" then
				roomscount = roomscount + 1
			end
		end
      if areascount >= roomscount then
         if mode == "gq" then
            lastGqType = "area"
         elseif mode == "cp" then
            lastCpType = "area"
         end
         SaveState()
         return "area"
      else
         if mode == "gq" then
            lastGqType = "room"
         elseif mode == "cp" then
            lastCpType = "room"
         end
         SaveState()
         return "room"
      end
   end
   
   function sort_list(list)
      for i = 1, #list do
         if list == nil or list[i] == nil then return end
         if list[i] ~= nil then
            list[i].sortarea = list[i].area
            if i>1 and list[i].mob == list[i-1].mob then
               list[i].sortarea = list[i-1].sortarea
            end
         end
      end
      local function tableSort(a, b)
         return (a.sortarea < b.sortarea) or (a.sortarea == b.sortarea and a.mob < b.mob)
      end
      table.sort(list, tableSort)
      return list
   end

	function filter_list(list)
      local type = get_list_type(list)
      
      for i=#list, 1, -1 do
         if list == nil or list[i] == nil then return end
         
         if type == "room" and list[i].type == "area" then
				local mobCount = 0
            for n = #list, 1, -1 do
               if list[i].mob == list[n].mob then
                  mobCount = mobCount + 1
               end
            end
            if mobCount > 1 then
               if xcpData["removed_guesses"] == nil then
                  xcpData["removed_guesses"] = {}
               end
               table.insert(xcpData["removed_guesses"], list[i])
               table.remove(list,i)
            end
			elseif type == "area" and list[i].type == "room" then
            
            local mobCount = 0
            for n = #list, 1, -1 do
               if list[i].mob == list[n].mob then
                  mobCount = mobCount + 1
               end
            end
            -- only remove extras! if it's the only entry for that mob make sure we keep it
            if mobCount > 1 then
               if xcpData["removed_guesses"] == nil then
                  xcpData["removed_guesses"] = {}
               end
               table.insert(xcpData["removed_guesses"], list[i])
               table.remove(list,i)
            end
			end
      end
         for i = #list, 1, -1 do
            local thisResult = get_mob_rooms(list[i].mob, list[i].area)
            
            if #thisResult > 0 then
               --tprint(thisResult)
               list[i].mobDB = thisResult
               DebugNote("Found " .. #thisResult .. " mobDB entries for " .. list[i].mob)
            end
         end
      
      DebugNote("filter_list: filtered size is: " .. #list)
		return list
	end
	
	function print_rooms_areas(list, command, silent)

      --local color_main_output = GetVariable("color_main_output") or "LightSkyBlue"
      --local color_list_headers = GetVariable("color_list_headers") or "Gray"
      local color_main_output = "LightSkyBlue"
      local color_list_headers = "Gray"
      local color_main_mobs = "Silver"
      local color_main_areas = "LightSkyBlue"
      local color_unknown_location = "DarkOrange"
      
      
      if (IsPluginInstalled(gui_id) and GetPluginInfo(gui_id, 17)) then
         color_main_output = GetPluginVariable(gui_id, "color_main_output") or "LightSkyBlue"
         color_list_headers = GetPluginVariable(gui_id, "color_list_headers") or "Gray"
         color_main_mobs = GetPluginVariable(gui_id, "color_main_mobs") or "Silver"
         color_main_areas = GetPluginVariable(gui_id, "color_main_areas") or "LightSkyBlue"
         color_unknown_location = GetPluginVariable(gui_id, "color_unknown_location") or "DarkOrange"
      end
      
      if list == nil then
         ColourNote("DarkOrange", "", "No item exists, or data busy (try again)")
         return
      end
		DebugNote("print_rooms_areas:" .. command .. ":" .. #list)
	
		--reset signature for next search
		lastMobSignature = ""
		
		local roomscount = 0
		local areascount = 0
		
		local mobNameLength = 0
		local areaNameLength = 0
      local roomNameLength = 0
		
		local strHeader
      --for k, v in pairs(list) do
      --print(v.mob)
      --end
      
         DebugNote("Pre-filtered list size is: " .. #list)
         list = filter_list(list)
		-- sort alpha by area (for rooms cps)
		-- keep duplicate mobname entries together
      -- let's try to remove duplicates using mobdb info
      
--      if list == nil then return end
--      for i=1,#list,1 do
--         list[i].sortarea = list[i].area
--         if i>1 and list[i].mob == list[i-1].mob then
--            list[i].sortarea = list[i-1].sortarea
--         end
--      end
      
--      table.sort(list, function(k1,k2) return k1.sortarea<k2.sortarea end)
    
      for k, v in pairs(list) do
			local currentMobNameLength = 0
			local currentAreaNameLength = 0
			local currentRoomNameLength = 0
         
         if v.type == "room" and v.roomName ~= nil then
            currentRoomNameLength = string.len(v.roomName)
            --print("Room is size " .. currentRoomNameLength)
         end
			if v.isDead ~= nil and v.isDead ~= "" then currentMobNameLength = 7 end
				currentMobNameLength = currentMobNameLength + string.len(v.mob)
         if currentRoomNameLength > roomNameLength then roomNameLength = currentRoomNameLength end
         if currentMobNameLength > mobNameLength then mobNameLength = currentMobNameLength end
			
			currentAreaNameLength =  currentAreaNameLength + string.len(v.areaId)
			if currentAreaNameLength > areaNameLength then areaNameLength = currentAreaNameLength end
			
		end
      if setting_reduceSpam ~= "1" then
			ColourNote(color_list_headers, "", "Type '" .. command .. " <Index>' or click link, to go to that item")
		end
		strHeader = "Index  " .. padRight("Target", mobNameLength + 4, " ") .. padRight("Area", areaNameLength + 2, " ") .. "Notes"
			ColourNote(color_list_headers, "", strHeader)
			ColourNote(color_list_headers, "", padRight("", string.len(strHeader), "-"))
    --print(roomNameLength)
		local index = 0
		for key, value in ipairs(list) do
		  
			index = index + 1
		
			local qty = ""

			if (value.qty > 1) then
				qty = string.format("%s * ", value.qty)
			end

			local mobText = qty .. value.mob
			local deadFlag = false
			if (value.isDead ~= nil and value.isDead ~= "") then
				mobText = mobText .. " [Dead]"
				deadFlag = true
			end
			
			DebugNote("xcp_index_line:" .. value.mob)
			local link
			local color
         local keyStr
         if value.mobDB and #value.mobDB > 0 then
            keyStr = string.format("[*%2d]", tonumber(key))
         else
            keyStr = string.format("[%3d]", tonumber(key))
			end
         color = color_main_output
         Hyperlink(command .. " " .. key, padRight(keyStr, 6, " "), "Start CP item " .. key, color, "black", 0, 1)
         if (deadFlag == false) then
				color = color_main_mobs
			else
				color = "DimGray"
			end
         
         Hyperlink(command .. " " .. key, padRight(mobText, mobNameLength +  1, " "), "Start CP item " .. key, color, "black", 0, 1)   
         color = color_main_output
         Hyperlink(command .. " " .. key, " - ", "Start CP item " .. key, color, "black", 0, 1)
			if (value.type == "area") then
				--link = string.format("%s - %s", padRight(keyStr, 6, " "), padRight(mobText, mobNameLength + 1, " "), padRight(value.areaId, areaNameLength + 1, " "))
            --link = string.format("%s - ", padRight(mobText, mobNameLength + 1, " "))
            link = nil
				if (deadFlag == false) then
					color = color_main_output
				else
					color = "DimGray"
				end
			elseif (value.type == "room") then
            
				link = string.format("%s (%5s) - ",
					padRight(value.roomName, roomNameLength + 1, " "),
					value.roomId)
   
               color = color_main_areas
			else -- unknown
				link = string.format("'%s' is Unknown", value.roomName)
				if (deadFlag == false) then
					color = "DarkOrange"
				else
					color = "DarkRed"
				end
			end
			if link ~= nil then
            Hyperlink(command .. " " .. key, link, "Start CP item " .. key, color, "black", 0, 1)
			end
         
			if (value.type == "area") then
               Hyperlink(command .. " " .. key, padRight(value.areaId, areaNameLength + 1, " "), "Start CP item " .. key, color_main_areas, "black", 0, 1)	
				if has_notes(value.areaId, nil) then
					Hyperlink("roomnote area " .. value.areaId , " [notes]", "Show notes for " .. key, "lightgreen", "black", 0, 1)	
				end
         elseif (value.type == "room") then
            link = string.format("%s [%2s - %2s]", padRight(value.areaId, areaNameLength + 1, " "), value.min, value.max)
            Hyperlink(command .. " " .. key, link, "Start CP item " .. key, color_main_areas, "black", 0, 1)	
			end
			print("")
		end
		
		if (index == 0) then
			ColourNote("darkorange", "", "   No campaign items to show.")
		end

		if setting_reduceSpam ~= "1" then
			ColourNote(color_list_headers, "", padRight("", string.len(strHeader), "-"))
		end

	end

	function goto_number(name, line, wildcards)
		--Note("goto_number: " .. wildcards.id)

		if (wildcards.id == nil or wildcards.id == "") then
			gotoIndex = 1
		else
			gotoIndex = tonumber(wildcards.id)
		end

		if (gotoList[gotoIndex] ~= nil) then
         CallPlugin(search_destroy_id, "hunt_trick_cancel")
			if (tonumber(gotoList[gotoIndex]) == nil) then
				-- go to an area
				Execute("xrt " .. gotoList[gotoIndex])
			else
				next_room = gotoList[gotoIndex]
            playerInfo.destRoom = tonumber(gotoList[gotoIndex])
				goto_roomid(gotoList[gotoIndex])
			end
		else
			ColourNote("darkorange", "", "No destination exists")
		end
	end

	function goto_roomid(roomid)
      if currentRoom ~= nil and currentRoom.roomid == tostring(roomid) then
         ColourNote("darkorange", "", "You're already in room #" .. roomid)
      end
		local dest_in_vidblain = is_vidblain_area(roomid)
		local both_in_vidblain = dest_in_vidblain and is_vidblain_area(currentRoom.roomid)


		if (dest_in_vidblain == true and both_in_vidblain == false) then
			Execute("xmapper move 11910")
			Execute("enter hole")

			local func = function() Execute("xmapper move " .. roomid) end
			execute_in_area("vidblain_hack", "vidblain", func)

		else
			Execute("xmapper move " .. roomid)
		end
	end

	local is_vidblain_area_sql =  
		"SELECT area " ..
		"FROM rooms " ..
		"WHERE uid = %s "

	function is_vidblain_area(roomid)

		if setting_vidblainHack == "false" then
			return false
		end

		local worldPath = GetInfo(66)..Trim(sanitize_filename(WorldName()))
		local db = assert(sqlite3.open(worldPath .. ".db"))

		local select = string.format (is_vidblain_area_sql, fixsql(roomid))
		for row in db:nrows(select) do
			--Note(row.area)
			local areaid = row.area
			if (areaid == "vidblain" or
				areaid == "imperial" or
				areaid == "darklight" or
				areaid == "sendhian" or
				areaid == "omentor") then
				
				db:close_vm()
				return true
			end
		end		
		db:close_vm()

		return false

	end

	function goto_next(name, line, wildcards)

		DebugNote("next:" .. next_room .. ":" .. currentRoom.roomid)
		if (tonumber(next_room) == tonumber(currentRoom.roomid)) then
			gotoIndex = gotoIndex + 1
		end

		if (gotoList[gotoIndex] ~= nil) then
			
			ColourNote("darkorange", "", "Goto - " .. gotoIndex .. " of " .. #gotoList)
			next_room = gotoList[gotoIndex]
			Execute("xmapper move " .. next_room)
		else
			ColourNote("darkorange", "", "No destination exists")
		end
		if setting_autoScan == "1" then
			SendNoEcho("scan here")
      elseif setting_autoCon == "1" then
         playerInfo.conInProgress = true
         EnableTrigger("trg_end_con2", true)
         SendNoEcho("con all")
		end
	end

	function goto_cp(name, line, wildcards)

		--cpIndex = tonumber(wildcards.index)
      local thisIndex = tonumber(wildcards.index)
		mode = "cp"
      xcpInProgress = true

		DebugNote("goto_cp:" .. wildcards.index)
		
		BroadcastPlugin(680, thisIndex)
		BroadcastPlugin(670, "cp")
		
       if cpList[thisIndex] ~= nil then
         last_xcpListItem = cpList[thisIndex]
         goto_list_item(cpList, thisIndex)
       elseif last_cpList[thisIndex] ~= nil then
         DebugNote("Using fallback list item.. " .. thisIndex .. " - " .. last_cpList[thisIndex].mob)
         last_xcpListItem = last_cpList[thisIndex]
         goto_list_item(last_cpList, thisIndex)
       else
         ColourNote("darkorange", "", "That CP item does not exist, or data busy (try again) #" .. thisIndex)
       end
	end
	
	function goto_gq(name, line, wildcards)
	
		--gqIndex = tonumber(wildcards.index)
      local thisIndex = tonumber(wildcards.index)
		mode = "gq"
      xcpInProgress = true

		DebugNote("goto_gq:" .. wildcards.index)
		
		BroadcastPlugin(680, thisIndex)
		BroadcastPlugin(670, "gq")
      
      if gqList[thisIndex] ~= nil then
         last_gqListItem = gqList[thisIndex]
         goto_list_item(gqList, thisIndex)
      elseif last_gqList[thisIndex] ~= nil then
         DebugNote("Using fallback GQ list item.. " .. thisIndex .. " - " .. last_gqList[thisIndex].mob)
         last_gqListItem = last_gqList[thisIndex]
         goto_list_item(last_gqList, thisIndex)
      else
         ColourNote("darkorange", "", "That GQ item does not exist, or data busy (try again) #" .. thisIndex)
      end
	end
	
	function goto_list_item(list, index)
		
		-- reset room list
		gotoList = {}
		gotoIndex = 1

		local localItem = list[index]
		local localRoom = currentRoom
      local mobName
		
		if (localItem ~= nil and localRoom ~= nil and localRoom.areaid ~= nil) then
		
			-- send this mob name to S&D plugin
			DebugTPrint("goto_list_item - localItem", localItem)
		
			if (localItem.type == "area") then
				DebugNote("area type")
				mobName = remote_guess_mob_name(localItem.mob, localItem.areaId, true)
				if (localRoom.areaid ~= localItem.areaId) then
					Execute("xrt " .. localItem.areaId)
				end

				--local func = function() Execute("x_ht " .. localItem.mob) end
            				local func = function() 
					if localItem.mobDB ~= nil then
						local skipResults = localItem.mobDB
						--sort the results first by frequency, then by room id
						local function tableSort(a, b)
						return (a.freq > b.freq) or (a.freq == b.freq and a.uid < b.uid)
						end
						table.sort(skipResults, tableSort)
						ColourNote("Yellow", "", "*** Mobdb has seen (" .. localItem.mob .. ") in the following rooms:")
						if skipResults ~= nil and #skipResults > 0 then
								local freq_total = 0
									for key, value in ipairs(localItem.mobDB) do
											freq_total = freq_total + tonumber(value.freq)
									end
									for key, value in ipairs(skipResults) do
											value.freq = math.floor((value.freq / freq_total) * 100)
									end
							local json = serialize.save_simple(skipResults)
							IPRINT_ROOMS(json)
						end
						--Execute("xpath " .. skipResults[1].uid)
						Note("")
               else
						if mobName ~= nil then 
							Execute("qw " .. mobName)
							mobName = nil
						end
					end
               --hunttrick the mob only if it is a cp, hunttrick no longer functions on gqs
					if mode == "cp" then
						Execute("x_ht " .. localItem.mob)
					else ColourNote("darkorange", "", "Skipping auto hunttrick for gq.")
					end
				end
				execute_in_area("goto_list_item_area", localItem.areaId, func)
			else -- "room"
				DebugNote("room type")
				mobName = remote_guess_mob_name(localItem.mob, localItem.areaId, true)
				
				search_rooms(localItem.roomName .. "|" .. localItem.areaId, "area", localItem.mob, true)
			end
      elseif localRoom ~= nil and localRoom.roomid == nil then
            ColourNote("darkorange", "", "Not sure what room we are in, type look or move.")      
		else
			ColourNote("darkorange", "", "No item exists, or data busy (try again)")
		end

	end

	local xrun_to_sql_uid =  
		"SELECT r.uid, r.name as room, r.area " ..
		"FROM rooms r " ..		
		"WHERE r.area like %s " ..
		"ORDER BY r.name "
		
	local xrun_to_sql_name =  
		"SELECT r.uid, r.name as room, r.area " ..
		"FROM rooms r " ..
		"INNER JOIN areas a ON a.uid = r.area " ..
		"WHERE r.area like %s OR a.name like %s " ..
		"ORDER BY r.name "
	
	function xrun_to(name, line, wildcards)
		local worldPath = GetInfo(66)..Trim(sanitize_filename(WorldName()))
		local db = assert(sqlite3.open(worldPath .. ".db"))

		-- HACK for ftii
		if (wildcards[1] == "ft2") then
			wildcards[1] = "ftii"
		end
		
		-- Check for xset marked room

		local startRoom = get_start_room(wildcards[1])
		if (startRoom ~= -1) then
			-- start room has been marked, we are done here
			ColourNote("darkorange", "", "x-runto (" .. startRoom .. ") xset marked as start room")
			--playerInfo.destRoom = tonumber(startRoom)
         goto_roomid(startRoom)
		else
			-- Room has not been marked for the area
			-- Search mapper DB for room with lowest id for the area
		
			-- try exact hit first
			local select = string.format (xrun_to_sql_uid, fixsql(wildcards[1]))
			DebugNote("xrun_to (1)- " .. select)
			
			for row in db:nrows(select) do
				ColourNote("darkorange", "", "x-runto (" .. row.uid .. ") " .. row.room .. " in " .. row.area .. " - exact match")
            --playerInfo.destRoom = tonumber(row.uid)
				goto_roomid(row.uid)
				
				db:close_vm()
				return
			end
			db:close_vm()
			
			-- try a wildcard match
			local like = fixsql("%" .. wildcards[1] .. "%")
			select = string.format (xrun_to_sql_name, like, like)
			DebugNote("xrun_to (2)- " .. select)

			for row in db:nrows(select) do
				ColourNote("darkorange", "", "x-runto (" .. row.uid .. ") " .. row.room .. " in " .. row.area .. " - 'like' match")
            --playerInfo.destRoom = tonumber(row.uid)
				goto_roomid(row.uid)
				
				db:close_vm()
				return
			end
			db:close_vm()
						
			ColourNote("darkorange", "", "No matching area found")	
		end					
	end
	
	function xroutes(name, line, wildcards)
		if (IsPluginInstalled("b6eae87ccedd84f510b74714") and GetPluginInfo("b6eae87ccedd84f510b74714", 17)) then
			for key, val in pairs(area_range) do
				startRoom = get_start_room(val.area)
				if (startRoom ~= nil) and (startRoom ~= -1) then
					ColourNote("MediumSeaGreen", "", "Xroute route from " .. currentRoom.roomid .. " to " .. startRoom .. " " .. val.area)
					Execute("mapper findpath " .. currentRoom.roomid .. " " .. startRoom)
					print("---")
				end
			end
		end
   end

	function xset_reducespam(name, line, wildcards)
		if setting_reduceSpam ~= "1" then
			setting_reduceSpam = "1"
			ColourNote("DarkOrange", "", "Reduce spam enabled")
		else
			setting_reduceSpam = "0"
			ColourNote("DarkOrange", "", "Reduce spam disabled")
		end
		SaveState()
	end
	
	function xset_autoscan(name, line, wildcards)
		if setting_autoScan ~= "1" then
			setting_autoScan = "1"
			ColourNote("DarkOrange", "", "Auto-scanning has been enabled")
		else
			setting_autoScan = "0"
			ColourNote("DarkOrange", "", "Auto-scanning has been disabled")
		end
		SaveState()
	end
   
   function xset_autocon(name, line, wildcards)
		if setting_autoCon ~= "1" then
			setting_autoCon = "1"
			ColourNote("DarkOrange", "", "Auto-conning has been enabled")
		else
			setting_autoCon = "0"
			ColourNote("DarkOrange", "", "Auto-conning has been disabled")
		end
		SaveState()
	end

	function xset_roomid(name, line, wildcards)
		if setting_roomid ~= "1" then
			setting_roomid = "1"
			ColourNote("DarkOrange", "", "Area name/roomid display mode enabled")
		else
			setting_roomid = "0"
			ColourNote("DarkOrange", "", "Area name/roomid display mode disabled")
		end
		SaveState()
	end
	
	function xset_silentmode(name, line, wildcards)
		if setting_silentMode ~= "1" then
			setting_silentMode = "1"
			ColourNote("DarkOrange", "", "CP/GQ Silent check mode enabled")
		else
			setting_silentMode = "0"
			ColourNote("DarkOrange", "", "CP/GQ Silent check mode disabled")
		end
		SaveState()
	end
	
   function xset_help(name, line, wildcards)
      ColourNote("MediumSeaGreen", "", xset_help_msg)
      Note("Current xset settings:")
      print("")
      Note("Silent mode is: " .. setting_silentMode)
      Note("Roomid mode is: " .. setting_roomid)
      Note("Vidblain mode is: " .. setting_vidblainHack)
      Note("Reducespam is: " .. setting_reduceSpam)
      Note("Autocon is: " .. setting_autoCon)
      Note("Autoscan is: " .. setting_autoScan)
      Note("Showpk is: " .. setting_showPK)
      Note("Noexp is: " .. setting_noexp)
      Note("Speed is: " .. speed)
      
   end
   
	function xset_pk(name, line, wildcards)
		if setting_showPK == "true" then
			setting_showPK = "false"
		else
			setting_showPK = "true"
		end
		ColourNote("DarkOrange", "", "Show PK room flag : " .. setting_showPK)
		SaveState()
	end

	function xset_to_mark(name, line, wildcards)
      if currentRoom.areaname == nil or currentRoom.areaid == nil then
         print("Failed to add start location unable to determine current area! Try moving or re-entering this area!")
         return
      end
      
		areaStartRooms[currentRoom.areaid] = { areaname = currentRoom.areaname, roomid = currentRoom.roomid }
		ColourNote("darkorange", "", currentRoom.roomid .. " set as starting room for " .. currentRoom.areaid)
		SaveState()
	end
	
	function get_start_room(area)

		area = string.lower(area)
		
		--find exact matches first in user-set starts and then in default start room locations

		if areaStartRooms[area] ~= nil then
			return areaStartRooms[area].roomid
		elseif areaDefaultStartRooms[area] ~= nil then
			return areaDefaultStartRooms[area].roomid
		end
		
		-- no exact matches, now let's look for partial matches in user-set starts
		for key, val in pairs(areaStartRooms) do
      --print(key)
			if string.match(string.lower(key), area) ~= nil then
				return val.roomid
			elseif string.match(string.lower(val.areaname), area) ~= nil then -- partial match on long area name
				return val.roomid
			end
		end
		-- alright last chance, checking default start rooms for partial match
		for key, val in pairs(areaDefaultStartRooms) do

			if string.match(string.lower(key), area) ~= nil then
				return val.roomid
			elseif string.match(string.lower(val.areaname), area) ~= nil then -- partial match on long area name
				return val.roomid
			end
		end
		return -1
		
	end

	---- room notes --------

	function room_note_area(name, line, wildcards)
		if (wildcards.areaid == "") then
			get_notes(currentRoom.areaid, nil)
		else
			get_notes(wildcards.areaid, nil)
		end
	end

	function room_note(name, line, wildcards)
		get_notes(nil, currentRoom.roomid)
	end
	
	function has_notes(areaid, roomid)
		local worldPath = GetInfo(66)..Trim(sanitize_filename(WorldName()))
		local db = assert(sqlite3.open(worldPath .. ".db"))

		local sql =  " SELECT b.uid, b.notes "
		sql = sql .. " FROM bookmarks b "
		if (areaid ~= nil) then
			sql = sql .. " INNER JOIN rooms r ON b.uid = r.uid "
			sql = sql .. " WHERE r.area = " .. fixsql(areaid)
		else
			sql = sql .. " WHERE b.uid = " .. fixsql(roomid)
		end
		sql = sql .. " ORDER BY b.uid "
		DebugNote(sql)

		local index = 0
		
		for row in db:nrows(sql) do
			return true
		end	
		return false
	end
	function get_notes(areaid, roomid, text_only)

		local worldPath = GetInfo(66)..Trim(sanitize_filename(WorldName()))
		local db = assert(sqlite3.open(worldPath .. ".db"))

		local sql =  " SELECT b.uid, b.notes "
		sql = sql .. " FROM bookmarks b "
		if (areaid ~= nil) then
			sql = sql .. " INNER JOIN rooms r ON b.uid = r.uid "
			sql = sql .. " WHERE r.area = " .. fixsql(areaid)
		else
			sql = sql .. " WHERE b.uid = " .. fixsql(roomid)
		end
		sql = sql .. " ORDER BY b.uid "
		DebugNote(sql)

		local index = 0
		if (areaid ~= nil) then
			Simulate("\nNotes for " .. getAreaName(areaid) .. "\n")
		end

		for row in db:nrows(sql) do
			index = index + 1

			if (text_only == true) then
				local line = string.format("  [ Note: %s ]", row.notes)
				Hyperlink("xmapper move " .. row.uid, line, "go to room " .. row.uid, "LightGreen", "black", 0, 1)
			else
				local line = string.format("  (%s) %s", row.uid, row.notes)
				Hyperlink("xmapper move " .. row.uid, line, "go to room " .. row.uid, "lightblue", "black", 0, 1)
				print("")
			end		
		end
		db:close_vm()
		
		if (areaid ~= nil and index == 0 and text_only ~= true) then
			Simulate("\tNo notes.\n")
		end
	end



	function getRoomByMob(mobName)
		local worldPath = GetInfo(66)..Trim(sanitize_filename(WorldName()))
		local db = assert(sqlite3.open(worldPath .. ".db"))

		local sql =  "SELECT roomid, mobname, count "
		sql = sql .. "FROM mobs "
		sql = sql .. "WHERE mobname = %s "
		sql = sql .. "ORDER BY count desc "

		for row in db:nrows(string.format (sql, fixsql(uid))) do
			db:close_vm()
			return row.name
		end
		db:close_vm()
	end


	function getAreaName(uid)
		local worldPath = GetInfo(66)..Trim(sanitize_filename(WorldName()))
		local db = assert(sqlite3.open(worldPath .. ".db"))

		local sql =  "SELECT name FROM areas WHERE uid = %s"
		for row in db:nrows(string.format (sql, fixsql(uid))) do
			db:close_vm()
			return row.name
		end
		db:close_vm()
		
		return uid
	end

	function getAreaUid(name)

		local worldPath = GetInfo(66)..Trim(sanitize_filename(WorldName()))
		local db = assert(sqlite3.open(worldPath .. ".db"))

		local sql =  "SELECT uid FROM areas WHERE name = %s order by uid "

		local areas = {}
		local index = 0
		DebugNote("getAreaUid:" .. fixsql(name))
		for row in db:nrows(string.format (sql, fixsql(name))) do
			DebugNote(row.uid .. ":" .. name)
			index = index + 1
			areas[index] = {uid = row.uid, name = name}
		end
		
		db:close_vm()
		return areas
	end


	function map_area(name, line, wildcards)
		search_rooms(wildcards.loc, 'area', wildcards.mob)
	end

	function map_area_all(name, line, wildcards)
		search_rooms(wildcards.loc .. "|all", 'all', wildcards.mob)
	end
	
	local search_rooms_sql = 
		"SELECT r.uid as uid, r.name as name, info, r.area as area, " ..
		"ifnull(a.name, r.area) as area_name, 1 as DisplayOrder " .. 
		"FROM rooms r " ..
		"LEFT OUTER JOIN areas a ON r.area = a.uid " ..
		"WHERE r.name = %s " ..
		"AND (%s = 'all' OR (a.name = %s OR r.area = %s)) " ..
		
		"UNION " ..
		
		"SELECT r.uid, r.name, info, r.area, " ..
		"ifnull(a.name, r.area) as area_name, 0 as DisplayOrder " .. 
		"FROM rooms r " ..
		"LEFT OUTER JOIN areas a ON r.area = a.uid " ..
		"WHERE r.name <> %s " ..
		"AND r.name LIKE %s " .. 
		"AND (%s = 'all' OR (a.name = %s OR r.area = %s)) " ..
		"ORDER BY Area, DisplayOrder DESC "
	
   
	function search_rooms(room, searchType, fullMobName, exact)
		DebugNote("search_rooms(" .. room .."," .. searchType .. "," .. fullMobName .. ")")
	
		if (room == nil or room == "") then
			Note("map_area() error : room is not known")
			return
		end

		-- room|area
		local parts = split(room, "[^|]+") -- pipe delimited
		local room = parts[1]
		local area_id
		if (#parts == 2) then
			area_id = parts[2]
		else
			if (currentRoom ~= nil) then
				area_id = currentRoom.areaid
			else
				ColourNote("darkorange", "", "Area not known, falling back to mapper list")
				Execute("mapper list " .. parts[1])
			end
		end

		if (room == nil) then
			Note("map_area() - Room not known")
			return
		end

      if exact then
         like = room
      else
         like = "%"..room.."%"
      end

		-- i forget what this does? Strip out a leading " ?
		--if string.sub(room,1,1) == "\"" and string.sub(room,-1) == "\"" then
		--	like = string.sub(room,2,-2)
		--end

		local select = string.format(search_rooms_sql, 
			fixsql(room), 
			fixsql(area_id), 
			fixsql(area_id), 
			fixsql(area_id), 
			fixsql(room), 
			fixsql(like), 
			fixsql(area_id), 
			fixsql(area_id), 
			fixsql(area_id))
		DebugNote(select)
			
		local worldPath = GetInfo(66)..Trim(sanitize_filename(WorldName()))
		local db = assert(sqlite3.open(worldPath .. ".db"))
		
		local results = {}
		local roomid_list = {}
		
		for row in db:nrows(select) do

			-- sanitize text room ids for "unmappable" rooms that are now being mapped
			local id = (tonumber(row.uid) or -1)
			results[#results + 1] = { 
				uid = id, 
				name = row.name,
				info = row.info,
				area = row.area_name,
				areaid = row.area or row.area_name -- make safe against bad dbs			
			}
			
			-- make a list of room ids
			if (id > 0) then
				roomid_list[#roomid_list + 1] = id
			end

		end   -- finding rooms
		db:close_vm()
		
		local mob_mapping = get_mobs_rooms(fullMobName, table.concat(roomid_list, ','))

		local freq_total = mob_mapping[-1] or 0
		DebugNote("freq_total:" .. freq_total)
		
		-- add mob to room mapping
		for key, value in ipairs(results) do
		
			local freq = mob_mapping[value.uid]
			if (freq ~= nil) then
				value.freq = math.floor((freq / freq_total) * 100)
			else
				value.freq = 0
			end
		end
      --sort the results first by frequency, then by room id
      local function tableSort(a, b)
         return (a.freq > b.freq) or (a.freq == b.freq and a.uid < b.uid)
      end
      table.sort(results, tableSort)
      
      if #results == 1 then
         if xcpInProgress then
            --run us straight there this is an xcp command with only 1 resulting room match
            playerInfo.destRoom = tonumber(results[1].uid)
            print_rooms(results)
            Execute("xpath " .. results[1].uid)
         else
            print_rooms(results)
         end
      else
         print_rooms(results)
      end
   xcpInProgress = false
	end
	
   function quest_info()
      --this disables the autorun to if only one entry for quest info (it seemed botty)
      xcpInProgress = false
   end
   
	function IPRINT_ROOMS(json)
		-- load serialize.save_simple data
		luastmt = "gPrintRooms = " .. json
		assert (loadstring (luastmt or "")) ()
		
		print_rooms(gPrintRooms)
	end
	
	-- uses results{ areaid, area, info, name, uid, freq }
	function print_rooms(results)
		-- print results
      
      local color_main_output = "LightSkyBlue"
      local color_list_headers = "Gray"
      local color_main_mobs = "Silver"
      local color_main_areas = "LightSkyBlue"
      local color_unknown_location = "DarkOrange"
      
      if (IsPluginInstalled(gui_id) and GetPluginInfo(gui_id, 17)) then
         color_main_output = GetPluginVariable(gui_id, "color_main_output") or "LightSkyBlue"
         color_list_headers = GetPluginVariable(gui_id, "color_list_headers") or "Gray"
         color_main_mobs = GetPluginVariable(gui_id, "color_main_mobs") or "Silver"
         color_main_areas = GetPluginVariable(gui_id, "color_main_areas") or "LightSkyBlue"
         color_unknown_location = GetPluginVariable(gui_id, "color_unknown_location") or "DarkOrange"
      end
      
		gotoList = {}
		mapper_area_index = 0
		local last_area = ""

		DebugTPrint("results", results)
		
		local roomNameLength = 0
		local hasPK = false
		local hasChance = false
		local strHeader
		
		for key,value in ipairs(results) do
			
			local currentRoomNameLength = 0
			local isPK = string.find((value.info or ""), "pk") ~= nil
			
			if (isPK == true and setting_showPK == "true") then hasPK = true end
			
			if value.freq > 0 then hasChance = true end
         
         if value.name == nil then return end
			
			currentRoomNameLength = currentRoomNameLength + string.len(value.name)

			if currentRoomNameLength > roomNameLength then roomNameLength = currentRoomNameLength end
		end
		
		if hasPK then roomNameLength = roomNameLength + 6 end
		
		
		if setting_reduceSpam ~= "1" then
			ColourNote(color_list_headers, "", "Type 'go <Index>' or click link, to go to that room")
		end

		gotoIndex = 1
		strHeader = "Index  " .. "Room #   " .. padRight("Room Name", roomNameLength + 3, " ") .. "SW"
		if hasChance then strHeader = strHeader .. "  Probability" end
		ColourNote(color_list_headers, "", strHeader)
		ColourNote(color_list_headers, "", padRight("", string.len(strHeader), "-"))
		
		for key, value in ipairs(results) do
			DebugNote("area: " .. value.areaid )
			
			if (last_area ~= value.areaid) then
			
				if (mapper_area_index == 0) then
					local areaLine = string.format("%s", value.areaid)
					Hyperlink("go " .. mapper_area_index, areaLine, "go to area " .. value.areaid, color_main_areas, "black", 0, 1)
					gotoList[mapper_area_index] = value.areaid
					
					mapper_area_index = mapper_area_index + 1
				else
					local areaLine = string.format("%s", value.areaid)
					Hyperlink("xrt " .. value.areaid, areaLine, "go to area " .. value.areaid, color_main_areas, "black", 0, 1)
				end				
				print("")
				last_area = value.areaid				
			end
		
			local isPK = string.find((value.info or ""), "pk") ~= nil
			local isPKText = " "
			DebugNote("isPK: " .. tostring(isPK))
			if (isPK == true and setting_showPK == "true") then
				isPKText = "[PK]"
			end
			local keyStr = string.format("[%3d]", tonumber(mapper_area_index))
			local line1 = string.format("%s  ",
				padRight(keyStr, 4, " "))
			Hyperlink("go " .. mapper_area_index, line1, "go to item " .. mapper_area_index, color_main_output, "black", 0, 1)
		
			line1 = string.format("(%5d)  ", tonumber(value.uid))
			Hyperlink("go " .. mapper_area_index, line1, "go to item " .. mapper_area_index, color_main_output, "black", 0, 1)
			
			-- mob name? 
			if (value.mobname ~= nil) then
				local mobline = padRight(value.mobname .. " ", 20, " ")
				Hyperlink("go " .. mapper_area_index, mobline, "go to item " .. mapper_area_index, color_main_mobs, "black", 0, 1)
			end
			
			if (isPK == true and setting_showPK == "true") then
				Hyperlink("go " .. mapper_area_index, isPKText .. " ", "go to item " .. mapper_area_index, "red", "black", 0, 1)
				line2 = padRight(value.name, roomNameLength - 5, " ")
				Hyperlink("go " .. mapper_area_index, line2, "go to item " .. mapper_area_index, color_main_areas, "black", 0, 1)
			else			
				line2 = padRight(value.name, roomNameLength, " ")
				Hyperlink("go " .. mapper_area_index, line2, "go to item " .. mapper_area_index, color_main_areas, "black", 0, 1)
			end
			
			Hyperlink("mapper where " .. value.uid, 
				"   {?}", 
				"click for speedwalk to this room", 
				"LightSteelBlue ", 
				"black", 
				0,
				1)
			gotoList[mapper_area_index] = value.uid
						
			if (value.freq > 0) then
				ColourTell ("DarkOrange", "black", " (" .. value.freq .. "%) ")
			end
			-- show room notes
			DebugNote("get note : " .. value.uid)
			get_notes(nil, value.uid, true)

			print("")
			mapper_area_index = mapper_area_index + 1
		end
			

		if (mapper_area_index == 0) then
			ColourNote("darkorange", "", "No matching rooms found.")
		end
		
		if setting_reduceSpam ~= "1" then
			ColourNote(color_list_headers, "", padRight("", string.len(strHeader), "-"))
		end	

	end

	function map_purgeroom (name, line, wildcards)
		local worldPath = GetInfo(66)..Trim(sanitize_filename(WorldName()))
		local db = assert(sqlite3.open(worldPath .. ".db"))

		Note(string.format ("delete from exits WHERE fromuid = %s;", fixsql(currentRoom.roomid)))
		dbcheck (db:execute (string.format ("delete from exits WHERE fromuid = %s;", fixsql(currentRoom.roomid))))
		Note(string.format ("delete from exits WHERE touid = %s;", fixsql(currentRoom.roomid)))
		dbcheck (db:execute (string.format ("delete from exits WHERE touid = %s;", fixsql(currentRoom.roomid))))
		Note(string.format ("delete from rooms_lookup WHERE uid = %s;", fixsql(currentRoom.roomid)))
		dbcheck (db:execute (string.format ("delete from rooms_lookup WHERE uid = %s;", fixsql(currentRoom.roomid))))
		Note(string.format ("delete from rooms WHERE uid = %s;", fixsql(currentRoom.roomid)))
		dbcheck (db:execute (string.format ("delete from rooms WHERE uid = %s;", fixsql(currentRoom.roomid))))
		db:close_vm()
		
		ColourNote("darkorange", "", "Purged room (" .. currentRoom.roomid .. ") from the mapper database.")
	end

	local cp_simulate_toggle = 0
	function cp_simulate(name, line, wildcards)	

		Simulate("\n")	

		if (cp_simulate_toggle == 0) then
			Simulate("You still have to kill * Isscheburqua (Insanitaria)\n")
			Simulate("You still have to kill * a rook citizen (Avian Kingdom)\n")
			Simulate("You still have to kill * Lea, the farmer's daughter (Farmyard)\n")
			Simulate("You still have to kill * a rook citizen (Nesting Home)\n")
			Simulate("You still have to kill * a demon school student (The School of Horror)\n")
			Simulate("You still have to kill * a hookle fish (Black Lagoon)\n")
			Simulate("You still have to kill * Harry (Unknown Tower - Dead)\n")
			Simulate("You still have to kill * a former court jester (The Labyrinth)\n")
			Simulate("You still have to kill * Parent (The Kitchen)\n")
			Simulate("You still have to kill * a wealth redistribution specialist (Empyrean, Streets of Downfall)\n")
			Simulate("You still have to kill * the reaching thorns (Eternal Autumn)\n")
			Simulate("You still have to kill * Redtooth (Mossflower Wood - Dead)\n")
			Simulate("You still have to kill * Castle Guard (Rebellion of the Nix)\n")
			Simulate("You still have to kill * Jules (The Amazon Nation)\n")
			Simulate("You still have to kill * an earth fiend (The Broken Halls of Horath)\n")
			Simulate("You still have to kill * the spirit of Bakarne (The Empire of Aiighialla)\n")
			Simulate("You still have to kill * Elfgar Sous-Fled (Some Place)\n")
			Simulate("You still have to kill * the heart of a sandstorm (Living Mines of Dak'Tai)\n")
			cp_simulate_toggle = 1
		else
			Simulate("You still have to kill * a former court jester (The Labyrinth)\n")
			Simulate("You still have to kill * the heart of a sandstorm (Buried in the Great Desert's unrelenting dunes)\n")
			Simulate("You still have to kill * Parent (The Kitchen)\n")
			Simulate("You still have to kill * a rhino seraph (A Corridor of Cinnamon and Silver)\n")
			Simulate("You still have to kill * A sprite prisoner (A cell)\n")
		
			cp_simulate_toggle = 0
		end
		Simulate("Note: Dead means that the target is dead, not that you have killed it.\n")
		Simulate("\n")
		Simulate("You have 6 days, 23 hours and 56 minutes left to finish this campaign.\n")
		Simulate("\n")	

	end

	function area_index_start_gag(name, line, wildcards)
		DebugNote("area_index_start_gag - " .. wildcards[1] .. ":" .. wildcards[2])
	end

	function area_index_start(name, line, wildcards)
		DebugNote("area_index_start")	
		EnableTrigger("trg_area_index_start", false)
		EnableTrigger("trg_area_index_line", true)
		EnableTrigger("trg_area_index_end", true)
		area_range = {}
	end

	function area_index_line(name, line, wildcards)
		DebugNote("area_index_line")
      --fixes for truncated names in area list
      if Trim(wildcards.area) == "The Abyssal Caverns of Sahuagi" then
         wildcards.area = "The Abyssal Caverns of Sahuagin"
      elseif Trim(wildcards.area) == "The Darkside of the Fractured" then
         wildcards.area = "The Darkside of the Fractured Lands"
      end
      
		area_range[Trim(wildcards.area)] = { 
			area = Trim(wildcards.area), 
			min = tonumber(Trim(wildcards.min)), 
			max = tonumber(Trim(wildcards.max)),
			lock = tonumber(Trim(wildcards.lock)) or 0 }		

	end

	function area_index_end(name, line, wildcards)
		DebugNote("area_index_end")

		EnableTrigger("trg_area_index_start", false)
		EnableTrigger("trg_area_index_start_gag", false)
		EnableTrigger("trg_area_index_line", false)
		EnableTrigger("trg_area_index_end", false)
		EnableTrigger("trg_area_index_gag1", false)

		setting_lastAreaCheck = os.time()
		SaveState()
		Execute("xset resume page size")
      --DoAfterSpecial(2, "xset resume page size", sendto.execute)

	end

	function capture_gq_line(name, line, wildcards)

		EnableTrigger("x_gq_line_end", true)

		if (gqList == nil) then
			gqList = {}
			gqIndex = 1
		end
      if xcpData["original"] == nil then
         xcpData["original"] = {}
      end
      table.insert(xcpData["original"], line)
		DebugNote("xgq_index_line:" .. wildcards.mob)
		gqIndex = get_rooms_areas(gqList, gqIndex, wildcards.where, wildcards.mob, wildcards.qty)
		
		
	end

	function capture_gq_line_end(name, line, wildcards)

		DebugNote("capture_gq_line_end")

		EnableTriggerGroup("x_gq", false)
		
      if gqList == nil then return end
         gqList = sort_list(gqList)
       --for i=1,#gqList,1 do
          --if gqList == nil or gqList[i] == nil then return end
          --gqList[i].sortarea = gqList[i].area
          --if i>1 and gqList[i].mob == gqList[i-1].mob then
             --gqList[i].sortarea = gqList[i-1].sortarea
          --end
       --end
       --table.sort(gqList, function(k1,k2) return k1.sortarea<k2.sortarea end)
      
      if not silentCheck then
         print_rooms_areas(gqList, "qq")
      else
         gqList = filter_list(gqList)
      end
		--if setting_silentMode ~= "1" then
		--	print_rooms_areas(gqList, "qq")
		--end
		last_gqList = gqList
		-- broadcast this data for other plugins to consume
		local ser = serialize.save_simple(gqList)
		BroadcastPlugin(667, ser)
      local gq_ind = 0
      for i = 1, #gqList do
         if last_gqListItem ~= nil and gqList[i].areaName == last_gqListItem.areaName and gqList[i].mob == last_gqListItem.mob then
            DebugNote("Found PERFECT match at " .. i)
            gq_ind = i
         end
      end
      BroadcastPlugin(680, gq_ind)
		mode = "gq"
      silentCheck = false
		
		-- if the user has vi assist plugin installed, send the data directly into their GQ buffer
		
		if (IsPluginInstalled(vi_assist_id) and GetPluginInfo(vi_assist_id, 17)) then
			local rc = CallPlugin(vi_assist_id, "clear_list", "gq")
			for index,value in ripairs(gqList) do
				local strListItem = ""
				if value.qty ~= nil and value.qty > 1 then strListItem = value.qty .. " " end
				strListItem = strListItem .. value.mob
				if value.roomName ~= "" and value.roomName ~= nil then
					strListItem = strListItem ..  "; in room: " .. value.roomName
				end
				strListItem = strListItem .. "; in area: " .. value.areaId
					if (value.isDead ~= nil and value.isDead ~= "") then
						strListItem = strListItem .. " - Mob is dead!"
					end
					local rc = CallPlugin(vi_assist_id, "review_addline", "GQ", strListItem)
					local rc, catid = CallPlugin(vi_assist_id, "find_catid_by_name", "GQ")
					--print("cat id is " .. catid)
					local rc = CallPlugin(vi_assist_id, "category_select", catid)
			end
		end
	end
	
	function capture_gq_end(name, line, wildcards)
		SetTriggerOption("trg_gq_check_note_scrambled", "omit_from_log", "n")
		SetTriggerOption("trg_gq_check_note_scrambled", "omit_from_output", "n")
		SetTriggerOption("x_gq_line_end_none", "omit_from_log", "n")
		SetTriggerOption("x_gq_line_end_none", "omit_from_output", "n")
      
      last_gqList = {}
      last_gqListItem = {}
      silentCheck = false
		local list = {}
		local ser = serialize.save_simple(list)
		BroadcastPlugin(667, ser)
      if (IsPluginInstalled(vi_assist_id) and GetPluginInfo(vi_assist_id, 17)) then
			local rc = CallPlugin(vi_assist_id, "clear_list", "gq")
      end
	end


	local test_toggle = 0
	function gq_list (name, line, wildcards)
		gqList = {}
      xcpData = {}
		gqIndex = 1

		EnableTrigger("x_gq_line", true)

		if setting_silentMode == "1" then
			silent_check_gq()
		else
			SendNoEcho("gq c")
		end
	end
	
	function gq_list_simulate (name, line, wildcards)

		gqList = {}
      xcpData = {}
		gqIndex = 1
      mode = "gq"

		EnableTrigger("x_gq_line", true)


		if (test_toggle == 0) then
			Simulate("\nYou still have to kill 1 * A kicking patient (A FAKE-private room)\n")
			Simulate("You still have to kill 1 * A snoring patient (Canyon Memorial Hospital)\n")
			Simulate("You still have to kill 1 * Sergeant Steel (The Armory)\n")
			Simulate("You still have to kill 1 * An abominable snowman (The Snowy Path)\n")
			Simulate("You still have to kill 1 * The senior assassin (Assassins' Scrying Chamber)\n")
			Simulate("You still have to kill 1 * Lord Kyron (The DarkLight)\n")
			Simulate("You still have to kill 1 * Buck (Imperial Nation)\n")
			Simulate("You still have to kill 1 * Anir (Kul Tiras)\n")
			Simulate("You still have to kill 1 * Bjorn (Realm of the Firebird)\n")
			Simulate("You still have to kill 2 * a crow (Realm of the Firebird)\n")
			Simulate("You still have to kill 2 * a gate guard (Realm of the Firebird)\n")
			Simulate("You still have to kill 1 * Destroyer of Minds (Deathtrap Dungeon)\n")
			Simulate("You still have to kill 1 * Rudolph (In the Air)\n")
			Simulate("You still have to kill 1 * a tester of fire (The experimenting room (Fire))\n")
			Simulate("You still have to kill 2 * a Bad Apple (Umari's Castle)\n")
			Simulate("You still have to kill 1 * Bhaal (Inside Valkur's Secret Laboratory)\n")
         Simulate("You still have to kill 1 * the third little pig (Pig Pen)\n\n")
			Simulate("Note: One or more target names in this gquest might be slightly scrambled.\r\n")
			
			test_toggle = 1
		elseif (test_toggle == 1) then
			-- TODO add 1 room and others area test here
         Simulate("\nYou still have to kill 1 * a foreign hero (The DarkLight)\n")
         Simulate("You still have to kill 1 * the troll guard (Anthrox)\n")
         Simulate("You still have to kill 1 * the saber tooth tiger (Anthrox)\n")
         Simulate("You still have to kill 1 * the triton (Anthrox)\n")
         Simulate("You still have to kill 1 * Horned lizard (Island of Lost Time)\n")
         Simulate("You still have to kill 1 * a knight of Northstar (Northstar)\n")
         Simulate("You still have to kill 1 * a militia man (Realm of the Firebird)\n")
         Simulate("You still have to kill 1 * Simon (Snuckles Village)\n")
         Simulate("You still have to kill 1 * a cow (The Empire of Talsa)\n")
         Simulate("You still have to kill 1 * a baby dragon (The Tournament of Illoria)\n")
			Simulate("Note: One or more target names in this gquest might be slightly scrambled.\r\n")
			test_toggle = 0
		end
	end
	
	function qq_report (name, line, wildcards)

		if (wildcards.channel ~= "") then

			local output = ""	
			local last_mob = ""
			local index = 0
			
			for key, value in ipairs(gqList) do
				if (last_mob ~= gqList[key].mob) then
					index = index + 1
					if (gqList[key].type == "area") then
						output = string.format("%s %s) %s - %s, ", output, index, gqList[key].mob, gqList[key].areaName)
					else
						output = string.format("%s %s) %s - %s (%s), ", output, index, gqList[key].mob, gqList[key].roomName, gqList[key].areaId)
					end
				end
				last_mob = gqList[key].mob
			end
			
			
			if (output ~= "") then
				SendNoEcho( wildcards.channel .. " " .. output)
			end
		end
	end

	function OnPluginInstall()
	
		if not db then db = assert (sqlite3.open(dbPath)) end
		DebugNote("opened WinkleGold_Database.db")
		if not sql_table_exists("mobs") then
         DebugNote("No tables found in database, creating fresh structure.")
			create_sql_tables()
      end
      db:close()
      
		-- Load string settings from disk
		
		setting_lastAreaCheck = GetVariable("areas_last_check")
		setting_reduceSpam = GetVariable("reduceSpam") or "1"
		setting_debug = GetVariable("Debug") or "0"
		setting_silentMode = GetVariable("silentMode") or "0"
      setting_roomid = GetVariable("roomId") or "0"
		setting_showPK = GetVariable("showPK") or "true"
		setting_autoScan = GetVariable("autoScan") or "0"
      setting_autoCon = GetVariable("autoCon") or "1"
      setting_noexp =  tonumber(GetVariable("noExp")) or 0
      lastCpType = GetVariable("lastCpType")
      lastGqType = GetVariable("lastGqType")
		setting_vidblainHack = GetVariable("XRunToCheckVidblain") or "false"
		playerInfo.levelTaken = tonumber(GetVariable("levelTaken"))
      
		-- Load tables from disk
		local area_range_str = GetVariable("areas_index")
		if area_range_str ~= nil then
			area_range = load( "return "..area_range_str)( )
      end
		local areaStartRooms_str = GetVariable("areaStartRooms")
      if areaStartRooms_str ~= nil then
         areaStartRooms = load( "return "..areaStartRooms_str)( ) 
      end
		if areaStartRooms ~= nil and tablelength(areaStartRooms) > 0 then
            DebugNote("Loaded start rooms successfully.")
		else
			areaStartRooms = areaDefaultStartRooms
         SaveState()
			DebugNote("User has no areaStartRooms set, let's give them the defaults.")
		end
		
		InstallMessage()
	end
   	
	function OnPluginSaveState()
		-- this will run when SaveState() is called or if mush is closing etc
		if areaStartRooms ~= nil and tablelength(areaStartRooms) > 0 then --not loaded or non-existant atm
         DebugNote(tablelength(areaStartRooms) .. " start rooms saved to disk")
			SetVariable("areaStartRooms", serialize.save_simple(areaStartRooms))
		end
      if playerInfo ~= nil and playerInfo.levelTaken ~= nil then
         SetVariable("levelTaken", playerInfo.levelTaken)
      end
		if area_range ~= nil and tablelength(area_range) > 0 then
			SetVariable("areas_index", serialize.save_simple(area_range))
		end
      if setting_lastAreaCheck then
         SetVariable("areas_last_check", setting_lastAreaCheck) --investigate crash for first time users here
      end
		SetVariable("reduceSpam", setting_reduceSpam)
      if lastCpType ~= nil then
         SetVariable("lastCpType", lastCpType)
      end
      if lastGqType ~= nil then
         SetVariable("lastGqType", lastGqType)
      end
      SetVariable("roomId", setting_roomid)
		SetVariable("Debug", setting_debug)
		SetVariable("autoScan", setting_autoScan)
      SetVariable("autoCon", setting_autoCon)
		SetVariable("silentMode", setting_silentMode)
		SetVariable("showPK", setting_showPK)
      SetVariable("noExp", setting_noexp)
		SetVariable("XRunToCheckVidblain", setting_vidblainHack)
	end

	------ Execute in Area ------

	local execute_in_area_array = {}

	function execute_in_area(id, areaId, functionPointer)

		execute_in_area_array[id] = { 
			areaId = areaId, 
			func = functionPointer, 
			index = 0, 
			active = true,
			lastState = 3, -- standing
			standIndex = 0 -- count of stands in a row
			}
		--tprint(execute_in_area_array)
		EnableTimer("execute_in_area_timer", true)

	end

	function execute_in_area_tick(name, line, wildcards)

		local localRoom = currentRoom
		local localState


		-- thread safety
		if (localRoom == nil) then
			DebugNote("Unknown Room")
			return
		end
		
		if (char_status == nill) then
			DebugNote("Unknown char status")
			return
		else
			localState = tonumber(char_status.state)
		end

		local isActive = false
		
		--tprint(execute_in_area_array)

		for index, value in pairs(execute_in_area_array) do
		
			DebugNote("loop - " .. index)
			if (value.active == true) then
		
				value.index = value.index + 1

				if (value.index > 100) then
					value.active = false
					DebugNote("** aborting quickwhere timer for " .. index .. ", took too long to get to destination")
					
				else

					DebugNote("state:" .. localState .. ",:" .. value.areaId .. "==" .. localRoom.areaid)

					if ((localState == 3 and value.lastState == 3) 
						and value.areaId == localRoom.areaid) then

						-- skip first timer tick
						value.index = value.index + 1
						value.standIndex = value.standIndex + 1
						if (value.standIndex < 2) then
							DebugNote("skip - index:" .. value.index)
						else
							DebugNote("executing - index:" .. value.index)
							value.func()
							value.active = false						
						end
					else
						-- still moving.. reset index
						value.standIndex = 0
					end
				end
			end
			
			value.lastState = localState
			
			if (value.active == true) then
				isActive = true
			end
			
		end
		
		-- no timer items active.. disable
		if (isActive == false) then
			DebugNote("disable timer")
			EnableTimer("execute_in_area_timer", false)
		end
	end
----------- MOB DATABASE -----------------------------

	function find_mob_area(name, line, wildcards)
		local mobName = wildcards[1]
		DebugNote("find_mob_area(" .. mobName .. ")")
	
		if (currentRoom == nil) then
			Note("I don't know where you are!")
			return
		end
      local list_index = string.match(mobName, '^[0-9]+$')
      if list_index ~= nil then
         if mode == "cp" and cpList ~= nil and #cpList > 0 and cpList[tonumber(list_index)] ~= nil then
            mobName = cpList[tonumber(list_index)].mob
            newMobName = remote_guess_mob_name(mobName, cpList[tonumber(list_index)].area)
         elseif mode == "gq" and gqList ~= nil and #gqList > 0 and gqList[tonumber(list_index)] ~= nil then
            mobName = gqList[tonumber(list_index)].mob
            newMobName = remote_guess_mob_name(mobName, gqList[tonumber(list_index)].area)
         else
            print("Unable to find mob # " .. list_index .. " on current " .. mode .. " list.")
            return
         end
      else
         local parts = split(mobName, "[^ ]+")
         for index = 1, #parts do
            parts[index] = "%" .. parts[index] .. "%"
         end
         mobName = table.concat(parts, " ")
      end
		DebugNote("mobName:" .. mobName)
      find_mob_rooms(mobName, currentRoom.areaid)
      if (IsPluginInstalled(search_destroy_id) and GetPluginInfo(search_destroy_id, 17)) then
         if list_index ~= nil and newMobName ~= nil then
            wildcards[1] = newMobName
         end
         error, short_mob_name = CallPlugin(search_destroy_id, "set_short_mob_name", wildcards[1], "find_mob_area")
         error, isexact = CallPlugin(search_destroy_id, "set_is_exact", 0, "find_mob_area")
		end
	end
	
	function find_mob_all(name, line, wildcards)
      local mobName = wildcards[1]
      local newMobName
      local parts = split(mobName, "[^ ]+")
      local list_index = string.match(mobName, '^[0-9]+$')
      if list_index ~= nil then
         if mode == "cp" and cpList ~= nil and #cpList > 0 and cpList[tonumber(list_index)] ~= nil then
            mobName = cpList[tonumber(list_index)].mob
            newMobName = remote_guess_mob_name(mobName, cpList[tonumber(list_index)].area)
         elseif mode == "gq" and gqList ~= nil and #gqList > 0 and gqList[tonumber(list_index)] ~= nil then
            mobName = gqList[tonumber(list_index)].mob
            newMobName = remote_guess_mob_name(mobName, gqList[tonumber(list_index)].area)
         else
            print("Unable to find mob # " .. list_index .. " on current " .. mode .. " list.")
            return
         end
            
      else
         for index = 1, #parts do
            parts[index] = "%" .. parts[index] .. "%"
         end
         mobName = table.concat(parts, " ")
      end
		--local mobName = "%" .. wildcards[1] .. "%"
		DebugNote("find_mob_all(" .. mobName .. ")")
      find_mob_rooms(mobName, nil)
      if (IsPluginInstalled(search_destroy_id) and GetPluginInfo(search_destroy_id, 17)) then
         if list_index ~= nil and newMobName ~= nil then
            wildcards[1] = newMobName
         end
         error, short_mob_name = CallPlugin(search_destroy_id, "set_short_mob_name", wildcards[1], "find_mob_all")
         error, isexact = CallPlugin(search_destroy_id, "set_is_exact", 0, "find_mob_all")
		end
		
	end

	local find_mob_rooms_sql1 = 
		" select mobname, roomid, freq " ..
		" from mobs " ..
		" where mobname like %s " ..
		" order by mobname, roomid"

	local find_mob_rooms_sql2 = 
		" select uid, name, area " ..
		" from rooms " ..
		" where uid in (%s) " 

	local find_mob_rooms_sql3 = 	
		" and area = '%s' "
	
	function get_mob_rooms(mobName, areaId)
      local csv = {}
      local result = {}
      local select = string.format(find_mob_rooms_sql1, fixsql(mobName))
      DebugNote(select)
		db = assert (sqlite3.open(dbPath))
		for row in db:nrows(select) do
			csv[#csv + 1] = row.roomid
		
         result[tostring(row.roomid)] = {
			  mobname = row.mobname,
			  freq = row.freq
			}
		end	
		db:close()
   
      DebugNote(#csv .. " rooms found")
      select = string.format(find_mob_rooms_sql2 .. find_mob_rooms_sql3, table.concat(csv, ","), areaId)
      DebugNote(select)
      
      local matches = {}
	
		db = assert (sqlite3.open(GetInfo (66) .. "Aardwolf.db"))
		for row in db:nrows(select) do
			DebugNote("row:" .. row.uid)
			if (result[tostring(row.uid)] ~= nil) then
				DebugNote("adding:" .. row.uid)
				matches[#matches + 1] = { 
					uid = row.uid, 
					name = row.name,
               mobname = result[row.uid].mobname,
					areaid = row.area,
					area = row.area,
					freq=result[row.uid].freq,
					info=""
				
					}
			end
		end
      db:close()	
	
		DebugNote(#matches .. " matches found")
      if #matches > 0 then
      else
      end
      return matches
   end
   local find_areaid_by_vnum = 
		" select uid, name, area " ..
		" from rooms " ..
		" where uid = '%s' "
   
   function get_room_info(vnum)
      db = assert (sqlite3.open(GetInfo (66) .. "Aardwolf.db"))
      select = string.format(find_areaid_by_vnum, vnum)
		for row in db:nrows(select) do
			--print("row:" .. row.area)
         return row
      end
      db:close()
      return
   end
   
   function find_mob_rooms(mobName, areaId)
		local result = {}
		local csv = {}
	
		local select = string.format(find_mob_rooms_sql1, fixsql(mobName))
		DebugNote(select)

		db = assert (sqlite3.open(dbPath))
		for row in db:nrows(select) do
			csv[#csv + 1] = row.roomid
		
			result[tostring(row.roomid)] = row.mobname
		end	
		db:close()

		DebugNote(#csv .. " rooms found")
		-- check return count
		if (#csv == 0) then
			Note("No mobs found matching that name")
			return	
		end	

		if (areaId == nil) then
			select = string.format(find_mob_rooms_sql2, 
				table.concat(csv, ","))
		else
			select = string.format(find_mob_rooms_sql2 .. find_mob_rooms_sql3, 
				table.concat(csv, ","), 
				areaId)
		end
		DebugNote(select)

		local matches = {}
      
		db = assert (sqlite3.open(GetInfo (66) .. "Aardwolf.db"))
		for row in db:nrows(select) do
			DebugNote("row:" .. row.uid)
			if (result[tostring(row.uid)] ~= nil) then
				DebugNote("adding:" .. row.uid)
				matches[#matches + 1] = { 
					uid = row.uid, 
					name = row.name,
					mobname = result[row.uid],				
					areaid = row.area,
					area = row.area,
					freq=0,
					info=""
				
					}
			end
		end	
      
		db:close()
	
		DebugNote(#matches .. " matches found")
		-- check return count
		if (#matches == 0) then
			Note("No mobs found matching that name in this area.")
			return	
		end	

	
		local json = serialize.save_simple(matches)
		IPRINT_ROOMS(json)
			--error = CallPlugin(extender_id, "IPRINT_ROOMS", json)
			--print_matches(matches)
	end

-- scan --

	function scan_trigger_start(name, line, wildcards)
		EnableTriggerGroup("trg_scan_trigger_end", true)
		scanComplete = false
		EnableTrigger("trg_scan_trigger_right_here", true)
      EnableTrigger("trg_scan_trigger_right_here_mob", true)
      --recent fix
		--EnableTrigger("trg_scan_trigger_right_here_mob", false)
		EnableTrigger("trg_scan_trigger_tag_end", true)
	end

	function scan_trigger_right_here(name, line, wildcards)
		EnableTriggerGroup("trg_scan_trigger_end", true)
		EnableTrigger("trg_scan_trigger_right_here", false)
		EnableTrigger("trg_scan_trigger_right_here_mob", true)
	end

	function remove_auras(mobname)
		DebugNote("before:" .. mobname)
	
		-- stupid gsub command uses % as an escape character
		mobname = string.gsub(mobname, "%(Golden Aura%)", "")
		mobname = string.gsub(mobname, "%(G%)", "")
		mobname = string.gsub(mobname, "%(Red Aura%)", "")
		mobname = string.gsub(mobname, "%(R%)", "")
		mobname = string.gsub(mobname, "%(White Aura%)", "")
		mobname = string.gsub(mobname, "%(W%)", "")
		mobname = string.gsub(mobname, "%(Hidden%)", "")
		mobname = string.gsub(mobname, "%(H%)", "")
		mobname = string.gsub(mobname, "%(Invis%)", "")
		mobname = string.gsub(mobname, "%(I%)", "")
		mobname = string.gsub(mobname, "%(Wounded%)", "")
		mobname = string.gsub(mobname, "%(Undead%)", "")
		mobname = string.gsub(mobname, "%(Stealth%)", "")
		mobname = string.gsub(mobname, "%(Animated%)", "")
		mobname = string.gsub(mobname, "%(A%)", "")
		mobname = string.gsub(mobname, "%(S%)", "")
		mobname = string.gsub(mobname, "%(Diseased%)", "")
		mobname = string.gsub(mobname, "%(D%)", "")
		mobname = string.gsub(mobname, "%(U%)", "")
		mobname = string.gsub(mobname, "%(Marked%)", "")
		mobname = string.gsub(mobname, "%(X%)", "")
		mobname = string.gsub(mobname, "%(Translucent%)", "")
		mobname = string.gsub(mobname, "%(T%)", "")
		mobname = string.gsub(mobname, "%(Angry%)", "")
		mobname = string.gsub(mobname, "%[AFK%]", "")
		mobname = string.gsub(mobname, "^ ", "")
		DebugNote("after:" .. mobname)
	
		return mobname

	end

	function scan_trigger_right_here_mob(name, line, wildcards, style)
      consider_messages = {
          a = { range = "-19 and below",  colour = "gray", },
          b = { range = "-10 to -19",     colour = "darkgreen", },
          c = { range = "-6 to -9",       colour = "forestgreen", },
          d = { range = "-2 to -6",       colour = "chartreuse", },
          e = { range = "-2 to +2",       colour = "springgreen", },
          f = { range = "+2 to +3",       colour = "darkgoldenrod", },
          g = { range = "+3 to +8",       colour = "gold", },
          h = { range = "+8 to +16",      colour = "tomato", },
          i = { range = "+16 to +21",     colour = "crimson", },
          j = { range = "+21 to +32",     colour = "lightpink", },
          k = { range = "+32 to +41",     colour = "darkmagenta", },
          l = { range = "+41 to +50",     colour = "darkviolet", },
          m = { range = "+50 and above",  colour = "magenta", },
            }
      if playerInfo.conInProgress then
         EnableTrigger("trg_end_con", true)
      end
      
		local mobname = remove_auras(wildcards.mob)
		local checkMob = check_list_mob(mobname)
      local conMob = consider_messages[name]
      local stripSpaces = 0
      
      
		if checkMob == "cp" then
         stripSpaces = 5
			ColourTell("Cyan", "", "[", "Yellow", "", "CP", "Cyan", "" , "] ")
         if playerInfo.conInProgress then
            playerInfo.conMobMatch = true
         end
		elseif checkMob == "gq" then
         stripSpaces = 5
			ColourTell("Cyan", "", "[", "Yellow", "", "GQ", "Cyan", "" , "] ")
         if playerInfo.conInProgress then
            playerInfo.conMobMatch = true
         end
		end
      
      if questInfo.mobName ~= nil then
         if string.lower(questInfo.mobName) == string.lower(mobname) then
            stripSpaces = 3
            checkMob = "quest"
            ColourTell("Cyan", "", "[", "Yellow", "", "Q", "Cyan", "" , "]")
            if conMob then Tell(" ") end
            if playerInfo.conInProgress then
               playerInfo.conMobMatch = true
            end
         end
      end
      
      if conMob then
         ColourTell("silver", "", mobname)
      else
         for index, value in ipairs(style) do
            if stripSpaces > 0 then
               value.text = string.gsub(value.text, string.rep(" ", stripSpaces), "")
            end
            ColourTell(RGBColourToName(value.textcolour), "", value.text)
         end
      end
      
      if conMob then
         ColourTell (conMob.colour, "", " (" .. conMob.range .. ")" )
      end
      
		if checkMob and checkMob ~= "quest" and (IsPluginInstalled(soundpack_id) and GetPluginInfo(soundpack_id, 17)) then
			--found target and suer has soundpack installed, let's trigger quest target found event to notify by sound
			local retval = CallPlugin(soundpack_id, "TriggerEvent", "quest_target_found")
		end
		print("")
		
		if scanComplete then
         return
      end
	
		if (mobname == "") then
			return
		end
	
		
		-- there might be a bug here somewhere... gmcparg is nil?
		-- get current room

		local roomid = currentRoom.roomid
      local results = {}
      local thisResult = {}
      thisResult.roomid = currentRoom.roomid
      if thisResult.roomid == nil or thisResult.roomid == "" then
         -- Avoid putting blank roomid data into the database--This seems to happen to people 
         -- sometimes, not sure if it's caused by some other conflicting plugin but hopefully this fixes it.
         return
	   end
      thisResult.areaid = currentRoom.areaid
	   thisResult.area = currentRoom.areaid
      thisResult.mobname = mobname
      thisResult.uid = currentRoom.roomid
	   thisResult.name = currentRoom.roomname
      thisResult.info = ""
      thisResult.freq = 1
      thisResult.updatedby = "plugin"
      table.insert(results, thisResult)
      if checkMob == "cp" then
         for i = 1, #cpList do
            if string.lower(mobname) == string.lower(cpList[i].mob) and cpList[i].area == currentRoom.areaid and cpList[i].mobDB == nil then
               cpList[i].mobDB = results
               local ser = serialize.save_simple(cpList)
               BroadcastPlugin(669, ser)
            end
         end
      elseif checkMob == "gq" then
         for i = 1, #gqList do
            if string.lower(mobname) == string.lower(gqList[i].mob) and gqList[i].area == currentRoom.areaid and gqList[i].mobDB == nil then
               gqList[i].mobDB = results
               local ser = serialize.save_simple(gqList)
               BroadcastPlugin(667, ser)
            end
         end
      elseif checkMob == "quest" then
--         print("quest mob detected")
      end
      mobname = sanitize(mobname):lower()
		DebugNote(mobname .. ", " .. roomid)

		-- TODO - break this into two sql statements - 1
		local insert = string.format("INSERT OR IGNORE INTO mobs (roomid, mobname, updatedby) SELECT '%s', '%s', 'plugin'", roomid, mobname)
		local increment = string.format("UPDATE mobs SET freq = freq + 1 WHERE roomid = '%s' AND mobname = '%s'", roomid, mobname)

		sqlQueue[#sqlQueue + 1] = { type="exec", sql=increment }
		sqlQueue[#sqlQueue + 1] = { type="exec", sql=insert }
	
	end

	function scan_trigger_end(name, line, wildcards)
		if sqlQueue ~= nil then
			DebugNote("scan_trigger_end() - Adding " .. #sqlQueue .. " mob entries into database with room #" .. currentRoom.roomid)
		end
      --print("Finished scan here mobs....")
		scanComplete = true
		EnableTriggerGroup("trg_scan_trigger_end", false)
      EnableTrigger("trg_end_scan", true)
	end
   
   function end_scan(name, line, wc)
      EnableTrigger("trg_end_scan", false)
      EnableTrigger("trg_scan_trigger_right_here", false)
      scanComplete = false
      DebugNote("Actual end of scan detected")
   end

   function create_mobsub(name, line, wildcards)
      --index = tonumber(wildcards.index)
      
      local mobSub = {}
		local list = {}
      wildcards.index = string.upper(wildcards.index)
      
      if wildcards.index == "Q" then
         if questInfo.mobName ~= nil then
            --print(questInfo.mobName, questInfo.area)
            local shortNames = {}
            for k,v in pairs(areaNames) do
               table.insert(shortNames, v.uid)
               if v.name == questInfo.area then
                  mobSub.name = questInfo.mobName
                  mobSub.area = v.uid
               end
            end
         else
            ColourNote("DarkOrange", "", "Not currently on a quest, cannot add mobsub for quest mob.")
            return
         end
      elseif wildcards.index == "C" then
         local shortNames = {}
         
         for k,v in pairs(areaNames) do
            table.insert(shortNames, v.uid)
         end
         mobSub.area = utils.choose ("Area Name", "Please enter area id", shortNames)
         if not mobSub.area then
            ColourNote("DarkOrange", "", "No area selected for custom mob substitution, cancelled!")
            return
         else
            mobSub.name = utils.inputbox ("Enter carefully the mobs exact name:\r\nExample: an amorous clam", "Enter the mob's full name", nil, "Courier", 9)
            if not mobSub.name then
               ColourNote("DarkOrange", "", "No name entered for custom mob substitution, cancelled!")
               return
            end
         end
      else
         if mode == "cp" then
            list = cpList
         elseif mode == "gq" then
            list = gqList
         end
         for key, value in ipairs(list) do
            if key == tonumber(wildcards.index) then mobSub.name = value.mob mobSub.area = value.areaId end
         end
      end
      if mobSub.name == nil then
         print("Unable to find mob name!")
         return
      end
      mobSub.subText = utils.inputbox ("Enter substitution for " .. mobSub.name, "Query", nil, "Courier", 9, { validate = str_not_empty } )
      if mobSub.subText == nil or mobSub.subText == "" then print("Cancelled!") return end
      mobSub.noHunt = utils.msgbox ("Mob is NoHunt?", "NoHunt?", "yesno", "?", 2)
      mobSub.noWhere = utils.msgbox ("Mob is NoWhere?", "NoWhere?", "yesno", "?", 2)
      mobSub.noScan = utils.msgbox ("Mob is NoScan?", "NoScan?", "yesno", "?", 2)
      mobSub.noHunt = string.upper(string.sub(mobSub.noHunt, 1, 1))
      mobSub.noWhere = string.upper(string.sub(mobSub.noWhere, 1, 1))
      mobSub.noScan = string.upper(string.sub(mobSub.noScan, 1, 1))
      mobSub.comment = utils.inputbox ("Enter optional comment for " .. mobSub.name, "Query", nil, "Courier", 9 )
      if mobSub.comment == nil then print("Cancelled!") return end
      --print("Adding sub for " .. mobSub.name .. " substitution text: " .. mobSub.subText .. " Area: " .. mobSub.area)
   
      local sqlString
      if get_substitute_name(mobSub.name, mobSub.area) ~= nil then
         print("Changed mob substitution to \"" .. mobSub.subText .. "\" for \"" .. mobSub.name .. "\" (" .. mobSub.area .. ")")
         sqlString = string.format("UPDATE mobsubs SET subname = %s, nohunt = %s, nowhere = %s, noscan = %s, comment = %s WHERE areaid = %s AND mobname = %s", fixsql(mobSub.subText), fixsql(mobSub.noHunt), fixsql(mobSub.noWhere), fixsql(mobSub.noScan), fixsql(mobSub.comment), fixsql(mobSub.area), fixsql(mobSub.name))
      else
         print("Created new mob substitution \"" .. mobSub.subText .. "\" for \"" .. mobSub.name .. "\" (" .. mobSub.area .. ")")
         sqlString = string.format("INSERT OR IGNORE INTO mobsubs (mobname, areaid, subname, nohunt, nowhere, noscan, comment) SELECT %s, %s, %s, %s, %s, %s, %s", fixsql(mobSub.name), fixsql(mobSub.area), fixsql(mobSub.subText), fixsql(mobSub.noHunt), fixsql(mobSub.noWhere), fixsql(mobSub.noScan), fixsql(mobSub.comment))
      end
      db = assert (sqlite3.open(dbPath))
      DebugNote(sqlString)
      DebugNote(dbcheck(db:execute(sqlString)))
      db:close()
   end

   function delete_mobsub(name, line, wildcards)
   
      local mobSub = {}
		
      if mode == "cp" then
			list = cpList
		elseif mode == "gq" then
			list = gqList
		end
      for key, value in ipairs(list) do
         if key == tonumber(wildcards.index) then mobSub.name = value.mob mobSub.area = value.areaId end
      end
      if get_substitute_name(mobSub.name, mobSub.area) == nil then print("No mob substitution exists for \"" .. mobSub.name .. "\"") return end
      
      local sqlString = string.format("DELETE from mobsubs WHERE areaid = %s AND mobname = %s", fixsql(mobSub.area), fixsql(mobSub.name))
      db = assert (sqlite3.open(dbPath))
      print("Deleted mob substitution for \"" .. mobSub.name .. "\" (" .. mobSub.area .. ")")
      DebugNote(sqlString)
      DebugNote(dbcheck(db:execute(sqlString)))
      --print(dbcheck(sqlString))
      db:close()
   end
   
   
   function get_substitute_name(mobname, areaid)
      local get_substitute_name_sql =  
         "SELECT * " ..
         "FROM mobsubs " ..
         "WHERE mobname like %s AND areaid = %s "
         
      local function file_exists(name)
         local f=io.open(name,"r")
         if f~=nil then io.close(f) return true else return false end
      end
      if not file_exists(dbPath) then
         DebugNote("WARNING: No mobsubs database file found. Not using substitution db.")
         return nil
      end
      DebugNote("get_substitute_name : " .. mobname ..":".. areaid)
	
      --TODO - cache the result of a found hit in a table
   --		local key = 
	
      local db = sqlite3.open(dbPath)
	

      local select = string.format (get_substitute_name_sql, fixsql(mobname), fixsql(areaid))
	
      for row in db:nrows(select) do
         DebugNote("substitute name: " .. row.subname)
         local sub = {
            mobName = row.mobname,
            areaId = row.areaid,
            subName = row.subname,
            noHunt = row.nohunt,
            noWhere = row.nowhere,
            noScan = row.noscan,
            roomId = row.roomid,
            comment = row.comment
         }
         db:close_vm()
         return sub
		
      end
	
      db:close_vm()
      return nil

   end
	function logPlayer(name, line, wildcards)
		local query = ""
		local playername = table.concat(wildcards, "")

		query = string.format("INSERT OR IGNORE INTO players (playername) VALUES ('%s')", sanitize(playername))

		db = assert (sqlite3.open(dbPath))
		dbcheck(db:execute(query))
	
		db:close()
	
	end --logPlayer

	function cleanupPlayers(name, line, wildcards)
		Note("Cleaning known players from mobs")

		local query = "DELETE FROM mobs WHERE mobname in (SELECT playername FROM players)"

		db = assert (sqlite3.open(dbPath))
		dbcheck(db:execute(query))
	
		db:close()

	end --cleanupPlayers

	local get_mobs_rooms_sql = 
		" select roomid, freq " ..
		" from mobs " ..
		" where roomid in (%s) " ..
		" and mobname = '%s' " ..
		" union " ..
		" select -1, sum(freq) " ..
		" from mobs " ..
		" where roomid in (%s) " ..
		" and mobname = '%s' " ..
		" order by 1 asc "

	function get_mobs_rooms(mobName, roomid_csv)
		DebugNote("get_mobs_rooms(" .. mobName .. "," .. roomid_csv .. ")")

		local result = {}

		mobName = sanitize(mobName:lower())
		local select = string.format(get_mobs_rooms_sql,
			roomid_csv,
			mobName,
			roomid_csv,
			mobName)
	
		DebugNote(select)

		db = assert (sqlite3.open(dbPath))
		for row in db:nrows(select) do
			result[row.roomid] = row.freq 
		end	
		db:close()

		return result
	end

	function check_mob_in_mapper(name, line, wildcards)

		db = assert (sqlite3.open(dbPath))

		local sql =  "SELECT * FROM mobs WHERE rowid = (SELECT MAX(rowid) from mobs) "
      --local sql =  "SELECT * FROM mobs WHERE  = (SELECT MAX(rowid) from mobs) "
		for row in db:nrows(sql) do
			tprint(row)
		end
	
		db:close()
	end
   
   
   function check_mob_in_mapper2(name, line, wildcards)

		db = assert (sqlite3.open(dbPath))

         if dbColumnExists(db, "rooms", "date_added") then
         end
		db:close()
   
   end

	function end_hunt_lookup(name, line, wildcards)
		DebugNote("end_hunt_lookup: " .. line)
		DebugNote("mode:" .. mode)

		--mode = "gq"
		if (mode == "gq" or line == "fm") then

			if (mode == "gq") then
				ColourNote("hotpink", "", full_mob_name .. " IS DEAD!")
			end
			get_names()

			if (short_mob_name ~= "" and full_mob_name ~= "") then
				Execute("fm " .. full_mob_name)
			end
		end
	end
   
   function end_con_all(name, line, wc)
      EnableTrigger("trg_end_con", false)
      EnableTrigger("trg_end_con2", false)
      DebugNote("End of con detected!")
      if playerInfo.conMobMatch then
         DebugNote("Mob was matched! No need for quickscan.")
         --Mob was matched, no need for scan
         playerInfo.conMobMatch = false
         playerInfo.conInProgress = false
      else
         DebugNote("Mob not matched, quickscanning!")
         playerInfo.conMobMatch = false
         playerInfo.conInProgress = false
         Execute("qs")
      end
   end
   
	function check_list_mob(mobname)
		DebugNote("checking list mob: " .. mobname)
		if mode == "gq" then
			if gqList ~= nil then
				for k, v in ipairs(gqList) do
					if string.lower(mobname) == string.lower(v.mob) then
						return "gq"
					end
				end
				return false
			end
		elseif mode == "cp" then
			if cpList ~= nil then
				for k, v in ipairs(cpList) do
					if string.lower(mobname) == string.lower(v.mob) then
						return "cp"
					end
				end
				return false
			end
		end
	end

	function get_names()
		DebugNote("get_names()")
		if (IsPluginInstalled(search_destroy_id) and GetPluginInfo(search_destroy_id, 17)) then
			-- get current room
			error, short_mob_name = CallPlugin(search_destroy_id, "get_short_mob_name")
			error, full_mob_name = CallPlugin(search_destroy_id, "get_full_mob_name")
			DebugNote(short_mob_name, ":", full_mob_name)
		end
	end
	
	----------- EXTERNAL CALLOUTS -----------------------------
	
	function remote_guess_mob_name(mobName, areaId, broadcast)

      DebugNote("remote_guess_mob_name call:" .. mobName .. ":" .. areaId)
	
		local rc, mobGuess, subMob = CallPlugin(
			search_destroy_id, 
			"IGuessMobNameBroadcast", 
			mobName,
			areaId)
			
		if (subMob ~= nil) then
			DebugNote(subMob)
		end
		
		DebugNote("remote_guess_mob_name return:" .. mobGuess)
		return mobGuess

	end


	------ Utils ------
	function sql_table_exists(table)
		for row in db:nrows("SELECT * FROM sqlite_master WHERE type = 'table' AND name = '" .. table .. "'") do
			return true
		end
		return false
	end


	function padRight(text, length, padChar)

		local padding = length - string.len(text)
		for i = 1, padding do
			text = text .. padChar
		end

		return text
	end
   
   function round(num, numDecimalPlaces)
     local mult = 10^(numDecimalPlaces or 0)
     return math.floor(num * mult + 0.5) / mult
   end
   
	-- reverse ipairs function
	function ripairs(t)
		local function ripairs_it(t,i)
			i=i-1
			local v=t[i]
			if v==nil then return v end
			return i,v
		end
		return ripairs_it, t, #t+1
	end

	function sanitize(str)
		str = string.gsub(str, "'", "''")
		return str

	end

	function sanitize_filename(str)
		str = string.gsub(str, "[^%w%s()_-]", "")
		return str
	end

	function quote(str)
		return "\""..str.."\""
	end


	function dbColumnExists(dbase, tbl, col)
		local sql = "select * from "..tbl.." limit 1;"
		local stmt = dbase:prepare(sql)
		local tb = stmt:get_names()
		local found = false
		for v = 1, stmt:columns() do
			print(tb[v]);
			if tb[v] == col then
				found = true;
				print("FOUND "..tb[v]);
			end
		end
		return found
	end
	
   function tablelength(table)
     local count = 0
     for _ in pairs(table) do count = count + 1 end
     return count
   end
   
	function dbcheck(code)

		if code ~= sqlite3.OK and    -- no error
			code ~= sqlite3.ROW and   -- completed OK with another row of data
			code ~= sqlite3.DONE then -- completed OK, no more rows
			local err = db:errmsg ()  -- the rollback will change the error message
			db:exec("ROLLBACK")      -- rollback any transaction to unlock the database
			error (err, 2)            -- show error in caller's context
		end -- if

	end -- dbcheck

	function fixsql(s)

		if s then
			return "'" .. (string.gsub (s, "'", "''")) .. "'" -- replace single quotes with two lots of single quotes
		else
			return "NULL"
		end
	end

	function fixbool(b)
		if b then
			return 1
		else
			return 0
		end -- if
	end -- fixbool

	function split(line, delim)

		local result = {}
		local index = 1

		for token in string.gmatch(line, delim) do
			result[index] = token
			index = index + 1
		end

		return result
	end

	function set_check_vidblain(name, line, wildcards)
		if setting_vidblainHack == "true" then
			setting_vidblainHack = "false"
		else
			setting_vidblainHack = "true"
	end

	  local msg = "off"
	  if setting_vidblainHack == "true" then
		msg = "on"
	  end
	  ColourNote ("darkorange", "", "No-portal vidblain assistance: " .. msg)
	end
   
----------- page size functions ---------------------------
	local page_size = 0
	local page_size_suspended = false
	
	function capture_page_size(name, line, wildcards)
   --print("capture pagesize")
		--Note(name .. ":" .. line .. "," .. tostring(table.concat(wildcards)))
		EnableTrigger("trg_page_size", false)
				
		local size = tonumber(wildcards[1])
		--Note("size:" .. tostring(size) .. "-" .. tostring(wildcards[1]))
		
			page_size = size or 0
			--Note(page_size)
         if page_size ~= 0 then
            EnableTrigger("event_paging_set", true)
         end
			SendNoEcho("pagesize 0")
	end
	
	function suspend_page_size(name, line, wildcards)
		if (page_size_suspended == false) then
			page_size_suspended = true
			--ColourNote("DarkGray", "", "--> Suspending paging... if enabled")
			EnableTrigger("trg_page_size", true)
			EnableTrigger("trg_page_size2", true)
         SendNoEcho("pagesize")
		end
	end	

	function resume_page_size(name, line, wildcards)
		--ColourNote("DarkGray", "", "--> Resuming paging... if enabled")
		EnableTrigger("trg_page_size", false)
		if (page_size ~= 0) then
			SendNoEcho("pagesize " .. page_size)
		end
		page_size_suspended = false
	end	
         
	check (AddTriggerEx("event_gq_note",
              "^(" ..
		 "You can be rewarded for (.+) more kills this level.*|"       ..
                 "Note\\: One or more target names in this gquest might be slightly scrambled.*|"    ..
                 "You may win (.+) more gquests at this level.*" ..
	      ")$",
	      "",
	      trigger_flag.RegularExpression,
	      -1, 0, "",
	      "", sendto.script, 1))

	--------- Sql Execution ------------

	function create_sql_tables()
	
	local sql_create_mobs_table =
	[[
      CREATE TABLE IF NOT EXISTS [mobs] ( [roomid] INTEGER NOT NULL, [mobname] TEXT NOT NULL, [freq] INTEGER NOT NULL DEFAULT (0), [updatedby] TEXT(20), CONSTRAINT [sqlite_autoindex_mobs_1] PRIMARY KEY ([roomid] ASC, [mobname]));
      CREATE TABLE IF NOT EXISTS "mobsubs" ("mobname" TEXT NOT NULL , "areaid" TEXT NOT NULL , "subname" TEXT NOT NULL , "nohunt" TEXT NOT NULL DEFAULT N, "nowhere" TEXT NOT NULL DEFAULT N, "noscan" TEXT NOT NULL DEFAULT N, "roomid" TEXT, "comment" TEXT, PRIMARY KEY ("mobname", "areaid"));
      CREATE TABLE IF NOT EXISTS "players" ("playername" TEXT PRIMARY KEY NOT NULL );
      CREATE TABLE IF NOT EXISTS `startrooms` ( `areaname` INTEGER, `arealongname` INTEGER, `roomid` INTEGER );
   ]]
   local retval = sql_check(sql_create_mobs_table)
   DebugNote("SQL: " .. sql_create_mobs_table .. "-retval=" ..retval)
	
	
	end

	function sql_check (query)
	   local code = db:exec(query)
	   if code ~= sqlite3.OK and    -- no error
	      code ~= sqlite3.ROW and   -- completed OK with another row of data
	      code ~= sqlite3.DONE then -- completed OK, no more rows
		 local err = db:errmsg ()  -- the rollback will change the error message
		 err = err.."\n\nCODE: "..code.."\nQUERY: "..query.."\n"
		 db:exec ("ROLLBACK")      -- rollback any transaction to unlock the database
		 error (err, 3)            -- show error in caller's context
	   end
	   return code
	end

	function RunSql(name, line, wildcards)

		local worldPath = GetInfo(66)..Trim(sanitize_filename(WorldName()))
		local db = assert(sqlite3.open(worldPath .. ".db"))

		local index = 0
		local sql = wildcards.sql
		ColourNote("darkorange", "", "running :" .. sql)
		for row in db:nrows(sql) do
			index = index + 1
			print("----------- record " .. index .. " -----------" )
			tprint(row)
	--		print (serialize.save ("row", row))
		end
		
		db:close_vm()
	end

	function ExecSql (name, line, wildcards)
		local worldPath = GetInfo(66)..Trim(sanitize_filename(WorldName()))
		local db = assert(sqlite3.open(worldPath .. ".db"))

		Note("executing " .. wildcards.sql)
	--	dbcheck (db:execute (fixsql(wildcards.sql)))
		db:execute(fixsql(wildcards.sql))

		db:close_vm()
		Note("ok")
	end

	function check_sql_queue(name, line, wildcards)
		local index = #sqlQueue
		if (index > 0) then
			--too much debug info!
			DebugNote(index .. " items to process")
			local item = sqlQueue[index]
			sqlQueue[index] = nil
			db = assert (sqlite3.open(dbPath))
			-- too much debug info!
			 DebugNote(item.type .. ":" .. item.sql)
			dbcheck(db:execute(item.sql))
		
			db:close()
		end
	end

   -------------- ROUTE CALCULATION -------------
   speedwalk_prefix = "run"
   mapper = require "aardmapper"
   
   local rooms = {}
   
   function xpath(name, line, wc)
      local src
      --print("Curr room: ")
      --tprint(currentRoom)
      local max_depth = configs.SCAN.depth or 300
      if wc.id == nil or wc.id == "" then
         print("No room specified!")
         return
      elseif currentRoom.roomid == nil or currentRoom.roomid == "" then
         ColourNote("darkorange", "", "No information for current room! Try moving or looking!")
         return
      end
      
      if currentRoom.num == "-1" then
         src = "nomap_"..currentRoom.name.."_"..currentRoom.zone
      else
         src = currentRoom.roomid
      end
      
      --tprint(currentRoom)
      --src = get_room_info(currentRoom.roomid)
      local dest = get_room_info(wc.id)
      if dest == nil then
         print("Destination room " .. wc.id .. " is unknown to the mapper!")
         return
      end
      
      local destArea = dest.area or "Unknown Room"
      --print("Okay attempting to find route from " .. src .. " (" .. ") to " .. dest.uid  .. " (" .. dest.area .. ")")

      local thistest = findpath(src, dest.uid)
      if thistest == nil then
      
         local results = {}
         local startRoom = get_start_room(dest.area)
         dest = get_room_info(startRoom)
         if dest == nil then
            print("Destination start room " .. startRoom .. " is unknown to the mapper!")
            return
         end
         if (dest.startRoom ~= -1) and (currentRoom.areaid ~= destArea) then
            --print("No route found within " .. max_depth .. " rooms, defaulting to start room " .. startRoom)
            ColourNote("darkorange", "", "No route found within " .. max_depth .. " rooms, defaulting to start room " .. startRoom .. " for " .. destArea)
            startRoomCheck = findpath(src, tonumber(startRoom))
            if startRoomCheck == nil then
               print("Unable to find path to area start room from here.")
               return
            end
            results[1] = { areaid = destArea, area = destArea, info = "", name = dest.name, uid = tonumber(startRoom), freq = 0}
            print_rooms(results)
            --Execute("xpath " .. startRoom)
            return
         else
            ColourNote("darkorange", "", "No route found within " .. max_depth .. " rooms.")
            return
         end
      end         
      
      local sw = mapper.build_speedwalk(thistest, "runto")
      if sw ~= nil then
         DebugNote("Route has been calculated as: " .. sw)
         mapper.start_speedwalk(thistest)
      end
   end
   
   function ExecuteWithWaits(cexit_command)
   require "wait"
   wait.make (function()
      SendNoEcho("echo {begin running}")
      local partial_cexit_command = cexit_command
      local strbegin,strend = string.find(partial_cexit_command,";?wait%(%d*.?%d+%);?")
      while strbegin do
         strbegin,strend = string.find(partial_cexit_command,";?wait%(%d*.?%d+%);?")
         if strbegin ~= nil and strbegin ~= 1 then
            Execute(string.sub(partial_cexit_command,1,strbegin-1))
         end
         if strend then
            local wait_time = tonumber(string.match(string.sub(partial_cexit_command,strbegin,strend),"wait%((%d*.?%d+)%)"))
            SendNoEcho("echo {mapper_wait}wait("..wait_time..")")
            line, wildcards = wait.regexp("^\\{mapper_wait\\}wait\\(([0-9]*\\.?[0-9]+)\\)",nil,trigger_flag.OmitFromOutput)
            Note("CEXIT WAIT: waiting for "..wait_time.." seconds before continuing.")
            BroadcastPlugin(999, "repaint")
            wait.time(wait_time)
            partial_cexit_command = string.sub(partial_cexit_command, strend+1)
         end
      end
      Execute(partial_cexit_command)
      SendNoEcho("echo {end running}")
   end)
end

   function load_room_from_database (uid)
   local room
   local u = tostring(uid)
   assert (uid, "No UID supplied to load_room_from_database")

   -- if not in database, don't look again
   --if room_not_in_database [u] then
      --return nil
   --end -- no point looking
   local db = assert (sqlite3.open(GetInfo (66) .. sanitize_filename(WorldName()) .. ".db"))

   for row in db:nrows(string.format ("SELECT * FROM rooms WHERE uid = %s", fixsql (u))) do
      room = {
         name = row.name,
         area = row.area,
         building = row.building,
         terrain = row.terrain,
         info = row.info,
         notes = row.notes,
         x = row.x or 0,
         y = row.y or 0,
         z = row.z or 0,
         noportal = row.noportal,
         norecall = row.norecall,
         exits = {},
         exit_locks = {},
         ignore_exits_mismatch = (row.ignore_exits_mismatch == 1)
      }

      for exitrow in db:nrows(string.format ("SELECT * FROM exits WHERE fromuid = %s", fixsql (u))) do
         room.exits [exitrow.dir] = tostring (exitrow.touid)
         room.exit_locks [exitrow.dir] = tostring(exitrow.level)
      end -- for each exit

   end   -- finding room

   if room then
      if not rooms then
         -- this shouldn't even be possible. what the hell.
         rooms = {}
      end
      rooms [u] = room
      for row in db:nrows(string.format ("SELECT * FROM bookmarks WHERE uid = %s", fixsql (u))) do
         rooms [u].notes = row.notes
      end   -- finding room

      return room
   end -- if found

   -- room not found in database
   --room_not_in_database [u] = true
   db:close_vm()
   return nil

end -- load_room_from_database

function load_bounce()
local db = assert (sqlite3.open(GetInfo (66) .. sanitize_filename(WorldName()) .. ".db"))
   for row in db:nrows("SELECT * FROM storage") do
      if row.name == "bounce_portal" or row.name == "bounce_recall" then
         loadstring(row.data or "")()
      end
   end
   db:close_vm()
end

   local bit = require("bit")
-- original findpath function idea contributed by Spartacus
function findpath(src, dst, noportals, norecalls)
   local mylevel = playerInfo.level or 200
   local mytier = playerInfo.tier or 0
   --let's not cache this value
   --if not rooms[src] then
      rooms[src] = load_room_from_database(src)
   --end
   if not rooms[src] then
      return
   end
   
   local walk_one = nil
   
   for dir,touid in pairs(rooms[src].exits) do
      if tostring(touid) == tostring(dst) and tonumber(rooms[src].exit_locks[dir]) <= mylevel and ((walk_one == nil) or (#dir > #walk_one)) then
         walk_one = dir -- if one room away, walk there (don't portal), but prefer a cexit
      end
   end
   if walk_one ~= nil then
      return {{dir=walk_one, uid=touid}}, 1
   end
   local depth = 0
   local max_depth = configs.SCAN.depth or 300
   local room_sets = {}
   local rooms_list = {}
   local found = false
   local ftd = {}
   local f = ""
   local next_room = 0

   if type(src) ~= "number" then
      src = string.match(src, "^(nomap_.+)$") or tonumber(src)
   end
   if type(dst) ~= "number" then
      dst = string.match(dst, "^(nomap_.+)$") or tonumber(dst)
   end

   if src == dst or src == nil or dst == nil then
      return {}
   end

   src = tostring(src)
   dst = tostring(dst)

   table.insert(rooms_list, fixsql(dst))

   local visited = ""
   local main_status = GetInfo(53)
   while not found and depth < max_depth do
      SetStatus(main_status.." (searching depth "..depth..")")
      BroadcastPlugin (999, "repaint")
      depth = depth + 1
      if depth > 1 then
         ftd = room_sets[depth-1] or {}
         rooms_list = {}
         for k,v in pairs(ftd) do
            table.insert(rooms_list, fixsql(v.fromuid))
         end -- for from, to, dir
      end -- if depth

      -- prune the search space
      if visited ~= "" then
         visited = visited..","..table.concat(rooms_list, ",")
      else
         if noportals then
            visited = visited..fixsql("*")..","
         end
         if norecalls then
            visited = visited..fixsql("**")..","
         end
         visited = visited..table.concat(rooms_list, ",")
      end
      local db = assert (sqlite3.open(GetInfo (66) .. sanitize_filename(WorldName()) .. ".db"))
      -- get all exits to any room in the previous set
      local q = string.format ("select fromuid, touid, dir from exits where touid in (%s) and fromuid not in (%s) and ((fromuid not in ('*','**') and level <= %s) or (fromuid in ('*','**') and level <= %s)) order by length(dir) asc",table.concat(rooms_list,","), visited,mylevel,mylevel+(mytier*10))
      local dcount = 0
      room_sets[depth] = {}
      for row in db:nrows(q) do
         dcount = dcount + 1
         -- ordering by length(dir) ensures that custom exits (always longer than 1 char) get
         -- used preferentially to normal ones (1 char)
         room_sets[depth][row.fromuid] = {fromuid=row.fromuid, touid=row.touid, dir=row.dir}
         if row.fromuid == "*" or (row.fromuid == "**" and f ~= "*" and f ~= src) or row.fromuid == src then
            f = row.fromuid
            found = true
            found_depth = depth
         end -- if src
      end -- for select

      if dcount == 0 then
         return -- there is no path from here to there
      end -- if dcount
   end -- while

   if found == false then
      return
   end

   -- We've gotten back to the starting room from our destination. Now reconstruct the path.
   local path = {}
   -- set ftd to the first from,to,dir set where from was either our start room or * or **
   ftd = room_sets[found_depth][f]

   --if (f == "*") or (f == "**") then
   
   if (f == "*" and rooms[src].noportal == 1) or (f == "**" and rooms[src].norecall == 1) then
      if rooms[src].norecall ~= 1 and bounce_recall ~= nil then
         table.insert(path, bounce_recall)
         if dst == bounce_recall.uid then
            return path, found_depth
         end
      elseif rooms[src].noportal ~= 1 and bounce_portal ~= nil then
         table.insert(path, bounce_portal)
         if dst == bounce_portal.uid then
            return path, found_depth
         end
      else
         local jump_room, path_type = findNearestJumpRoom(src, dst, f)
         if not jump_room then
            return
         end
         local path, first_depth = findpath(src,jump_room, true, true) -- this could be optimized away by building the path in findNearestJumpRoom, but the gain would be negligible
         if bit.band(path_type, 1) ~= 0 then
            -- path_type 1 means just walk to the destination
            return path, first_depth
         else
            local second_path, second_depth = findpath(jump_room, dst)
            for i,v in ipairs(second_path) do
               table.insert(path, v) -- bug on this line if path is nil?
            end
            return path, first_depth+second_depth
         end
      end
   end

   table.insert(path, {dir=ftd.dir, uid=ftd.touid})

   next_room = ftd.touid
   while depth > 1 do
      depth = depth - 1
      ftd = room_sets[depth][next_room]
      next_room = ftd.touid
-- this caching is probably not noticeably useful, so disable it for now
--      if not rooms[ftd.touid] then -- if not in memory yet, get it
--         rooms[ftd.touid] = load_room_from_database (ftd.touid)
--      end
      table.insert(path, {dir=ftd.dir, uid=ftd.touid})
   end -- while
   return path, found_depth
end -- function findpath
	
function findNearestJumpRoom(src, dst, target_type)
   local depth = 0
   local max_depth = configs.SCAN.depth or 300
   local mylevel = playerInfo.level
   local mytier = playerInfo.tier
   local room_sets = {}
   local rooms_list = {}
   local found = false
   local ftd = {}
   local destination = ""
   local next_room = 0
   local visited = ""
   local path_type = ""

   table.insert(rooms_list, fixsql(src))
   local main_status = GetInfo(53)
   while not found and depth < max_depth do
      SetStatus(main_status.." (searching jump depth "..depth..")")
      BroadcastPlugin (999, "repaint")
      depth = depth + 1

      -- prune the search space
      if visited ~= "" then
         visited = visited..","..table.concat(rooms_list, ",")
      else
         visited = table.concat(rooms_list, ",")
      end
      local db = assert (sqlite3.open(GetInfo (66) .. sanitize_filename(WorldName()) .. ".db"))
      -- get all exits to any room in the previous set
      local q = string.format ("select fromuid, touid, dir, norecall, noportal from exits,rooms where rooms.uid = exits.touid and exits.fromuid in (%s) and exits.touid not in (%s) and exits.level <= %s order by length(exits.dir) asc",
                  table.concat(rooms_list,","), visited, mylevel)
      local dcount = 0
      --print(q)
      for row in db:nrows(q) do
         dcount = dcount + 1
         table.insert(rooms_list, fixsql(row.touid))
         -- ordering by length(dir) ensures that custom exits (always longer than 1 char) get
         -- used preferentially to normal ones (1 char)
         if ((bounce_portal ~= nil or target_type == "*") and row.noportal ~= 1) or ((bounce_recall ~= nil or target_type == "**") and row.norecall ~= 1) or row.touid == dst then
            path_type = ((row.touid == dst) and 1) or ( (((row.noportal == 1) and 2) or 0) + (((row.norecall == 1) and 4) or 0) )
            -- path_type 1 means walking to the destination is closer than bouncing
            -- path_type 2 means the bounce room allows recalling but not portalling
            -- path_type 4 means the bounce room allows portalling but not recalling
            -- path_type 0 means the bounce room allows both portalling and recalling
            destination = row.touid
            found = true
            found_depth = depth
         end -- if src
      end -- for select
      db:close_vm()

      if dcount == 0 then
         return -- there is no path to a portalable or recallable room
      end -- if dcount
   end -- while
   if found == false then
      return
   end
   
   return destination, path_type, found_depth
end
   -------------- DEBUG --------------------

	function xlist(name, line, wc)
      if xcpData["original"] == nil then return end
      print("List debug data:\r\n\r\n")
      for i = 1, #xcpData["original"] do
         print(xcpData["original"][i])
      end
      if xcpData["removed_guesses"] ~= nil then
         print("\r\nRemoved S&D guesses:\r\n")
         --for i = 1, #xcpData["removed_guesses"] do
            --print(xcpData["removed_guesses"][i])
         --   require "tprint"
           -- tprint(xcpData["removed_guesses"][i])
           -- print("\r\n")
            --xcpData["removed_guesses"][i]
         --end
         local removedStr = ""
         for i = 1, #xcpData["removed_guesses"] do
            if xcpData["removed_guesses"][i].removed_reason == "level" then
               removedStr = "(level) "
            else
               removedStr = "(wrong type) "
            end
            removedStr = removedStr .. xcpData["removed_guesses"][i].mob .. " - " .. xcpData["removed_guesses"][i].areaId
            if xcpData["removed_guesses"][i].roomName ~= nil then
               removedStr = removedStr .. " - " .. xcpData["removed_guesses"][i].roomName
            end
            print(removedStr)
         end
      
      end
      
      if mode == "cp" and lastCpType ~= nil then
         
         print("List type determination: " .. lastCpType)
         
      elseif mode == "gq" and lastGqType ~= nil then
         
         print("List type determination: " .. lastGqType)
      end
   end
   
   function ext_debug(name, line, wildcards)
	
		--if (GetVariable("Debug") == "1") then
		if setting_debug == "1" then
			setting_debug = "0"
			print("")
			Note("Debug mode has been disabled.")
			print("")
		else
			--SetVariable("Debug", "1")
			setting_debug = "1"
			print("")
			Note("Debug mode has been enabled.")
			print("")
		end
		SaveState()

	end		
	
	function DebugNote(text)
		--if (GetVariable("Debug") == "1") then
		if setting_debug == "1" then
			Note("Extender ~ " .. text)
		end
	end

	function DebugTPrint(title, obj)
		--if (GetVariable("Debug") == "1") then
		if setting_debug == "1" then
			DebugNote(title .. " : " .. serialize.save_simple(obj))
		end
	end


	-------------- INSTALL MESSAGE ------------------
	function InstallMessage()
		ColourNote("MediumSeaGreen", "", "+======================[", "gold", "", "Win", "palegoldenrod", "", "kleG", "gold", "", "old", "MediumSeaGreen", "", "]======================+")
		ColourNote("MediumSeaGreen", "", "+ Extender Installed - type 'extender help' for options  +")
		ColourNote("MediumSeaGreen", "", "+========================================================+")
	end

   xset_help_msg = [[
>   xset
        - Display current xset settings and options
        
>   xset noexp <threshold>
        - Sets noexp threshold at the number set, this will automatically toggle
          noexp on if you are able take a CP to prevent leveling. If you
          set this to 0 it disables noexp.

>   xset mark
        - Sets the current room you are in to be the "first" room of that area
        
>   xset speed
        - Toggles the use of mapper goto/walkto for all movement commands
		
>   xset speed <walk|run>
        - changes the use of mapper goto/walkto for all movement commands

>   xset pk
        - Toggles the display of PK flag in room searches

>   xset roomid
        - Toggles the display of area name/roomid when moving or looking in a room
        	
>   xset vidblain
        - Toggles a hack that will allow you to speedwalk to vidblain areas if you do not have a portal to use.

>   xset autoscan
        - Toggles autoscan after arriving at destination. This collects information for your mob database.
	
>   xset silentmode
        - Toggles hiding cp/gq checks from main window unless you do a manual check
		
>   xset reset gui
        - Will reset the X, Y and Z position of the Extender GUI

>   xset reducespam
        - Removes "Ignoring due to level messages" from cp/gq entries and also help text (xcp # and go # instructions in cp/gq check output)
          This is enabled by default, if you outlevel your cp and need to see it, toggle it back on.
]]
]]>
</script>

</muclient>
